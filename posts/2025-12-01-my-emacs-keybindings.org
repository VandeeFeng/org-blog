#+title: æˆ‘çš„ Emacs é”®ä½è®¾ç½®
#+date: <2025-12-01 13:37>
#+description: ç°åœ¨ vibe è¿™ä¹ˆæ–¹ä¾¿äº†ï¼Œä¸ºä»€ä¹ˆè¿˜è¦åœ¨è¿™ä¸ªä¸Šé¢èŠ±è¿™ä¹ˆå¤šå¿ƒæ€ï¼Ÿæˆ‘è§‰å¾—ç”¨é”®ç›˜æ‰“å­— coding å’Œå¼¹å‰ä»–çš„æ„Ÿè§‰å¾ˆåƒã€‚åœ¨ Emacs é‡Œé…ç½®è¿™äº›é”®ä½å¯¹æˆ‘æ¥è¯´ï¼Œå°±åƒåœ¨è°ƒç´å¼¦ï¼Œè°ƒåˆæˆå™¨ä¸€æ ·ã€‚vibe æ›´å¤šçš„æ˜¯äº«å—ç»“æœï¼Œè€Œè¿™äº›åˆ™æ˜¯äº«å—è¿‡ç¨‹ã€‚
#+filetags: Emacs


* TL;DR
æˆ‘æ›´å–œæ¬¢åœ¨ Emacs é‡Œç¼–è¾‘æ–‡å­—å’Œä»£ç ï¼Œä½†æ˜¯æ›´ä¹ æƒ¯ vim çš„ç¼–è¾‘æ¨¡å¼å’Œè®¾è®¡ï¼ŒEmacs é‡ŒåŸç”Ÿçš„ Ctrl ç»„åˆé”®è®¾è®¡å¯¹äºé¢‘ç¹çš„ä»£ç ç¼–è¾‘æ¥è¯´ï¼Œæœ‰ç‚¹åäººç±»ã€‚

* ç»„åˆå¿«æ·é”® VS åºåˆ—å¿«æ·é”®
ç»„åˆå¿«æ·é”®ä½ï¼šCtrl+Cï¼Œåºåˆ—å¿«æ·é”®ï¼šleader key + æŒ‰é”®ï¼ŒSpace -> Cã€‚

- ç»„åˆå¿«æ·é”®çš„ä¼˜åŠ¿: ç›¸åº”æ›´å¿«ï¼Œéœ€è¦æ‰§è¡Œé”®ä½æ“ä½œçš„ç»å¯¹æ¬¡æ•°æ›´å°‘ï¼ŒæŒ‰ä¸€æ¬¡ç»„åˆé”®è§†ä¸ºä¸€æ¬¡é”®ä½æ“ä½œã€‚
- åºåˆ—å¿«æ·é”®çš„ä¼˜åŠ¿: é”®ä½çš„è®¾ç½®æ›´åŠ çµæ´»ï¼Œæ‰‹æŒ‡æ›´è½»æ¾ã€‚ä½†æ˜¯éœ€è¦æ‰§è¡Œçš„æŒ‰é”®æ“ä½œçš„ç»å¯¹æ¬¡æ•°æ›´å¤šï¼ŒåŒæ ·æŒ‰ä¸€æ¬¡æŒ‰é”®è§†ä¸ºä¾æ¬¡é”®ä½æ“ä½œã€‚

æˆ‘è®¤ä¸ºå®ƒä»¬å¯¹åº”ç€ä¸¤ç§æ€ç»´æ¨¡å¼:

- ç»„åˆå¿«æ·é”®é‡Œçš„ Ctrlã€Altã€Shiftã€Command æ˜¯é™„åŠ é”®ï¼Œè¿™äº›ä¸åŒçš„é™„åŠ é”®ä½æ˜ å°„ä¸åŒçš„åŠŸèƒ½ã€‚åœ¨ window é‡Œï¼Œå’Œåº”ç”¨çª—å£ç›¸å…³çš„èœå•æ“ä½œé€šå¸¸æ˜¯ Altï¼Œå’Œç³»ç»Ÿç›¸å…³çš„é€šå¸¸æ˜¯ Winã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯å¸¸è§„æŒ‰é”®+åŠŸèƒ½çš„å åŠ ç»„åˆã€‚Mac é‡Œçš„ Option å’Œ Command åŒç†ã€‚

- åºåˆ—å¿«æ·é”®åˆ™æ˜¯è®¾å®šä¸€ä¸ª leader key ä½œä¸ºåŠŸèƒ½çš„å…¥å£ï¼Œä¾‹å¦‚ Nvim é‡Œé€šå¸¸ Space ä½œä¸º leader keyï¼ŒSpace -> fï¼Œè¡¨ç¤ºå’Œ file æ–‡ä»¶ç›¸å…³çš„ï¼ŒSpace -> f -> rï¼Œè¡¨ç¤ºæµè§ˆæœ€è¿‘çš„æ–‡ä»¶ recent filesã€‚å®ƒæ˜¯ä¸€ç§é€’è¿›çš„å±‚çº§è®¾è®¡ã€‚ä¸åŒçš„åŠŸèƒ½é€‰æ‹©ä¸åŒçš„ leader keyï¼Œvim é‡Œçš„ g ä¹Ÿå°±æ˜¯ä¸€ä¸ª leader keyã€‚

åœ¨ Emacs é‡Œï¼ŒC-x(Ctrl+x) æ˜¯å’Œ window çª—å£ç›¸å…³çš„å¿«æ·é”®ï¼Œè¿™ä¸ªç»„åˆé”®å®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ª leader keyã€‚ç”±äº Emacs å’Œé€šå¸¸çš„æ–‡å­—ç¼–è¾‘å™¨é‡Œæ²¡æœ‰ vim çš„è¾“å…¥æ¨¡å¼çš„åŒºåˆ†ï¼Œéƒ½æ˜¯æŒ‰é”®ç›´æ¥è¾“å…¥æ–‡å­—ï¼Œå› æ­¤å¿…é¡»å¾—åŠ ä¸Š Ctrl è¿™ä¸ªåŠŸèƒ½é™„åŠ é”®é¿å…è¾“å…¥å­—ç¬¦ã€‚

Vim æœ‰ä¸‰ç§ç¼–è¾‘æ¨¡å¼ï¼šNormalï¼ŒVisualï¼ŒInsertã€‚normal å¯¹åº”å…‰æ ‡çš„ç§»åŠ¨ï¼Œvisual å¯¹åº”åŒºåŸŸé€‰å®šï¼Œinsert å¯¹åº”è¾“å…¥ã€‚æŒ‰ v è¿›å…¥ visualï¼Œiã€aã€sã€c éƒ½å¯ä»¥è¿›å…¥ insertï¼Œjk å¿«é€Ÿè¿æŒ‰åˆ™æ˜¯é€€å‡º insertã€‚jkhl åˆ†åˆ«å¯¹åº”å…‰æ ‡çš„ä¸‹ä¸Šå·¦å³ç§»åŠ¨ï¼Œå…¶ä»–çš„å°±ä¸å±•å¼€äº†ã€‚Vim è¿™å¥—è®¾è®¡é€»è¾‘å®ç°äº†ä¸ä¾èµ–é¼ æ ‡çš„å…¨é”®ç›˜æ–‡æœ¬ç¼–è¾‘å™¨é‡Œçš„å…‰æ ‡ç§»åŠ¨ï¼Œé¡µé¢æ»šåŠ¨ï¼Œå¿«é€Ÿæ›´æ”¹ï¼Œåˆ é™¤ï¼ŒæŸ¥æ‰¾ã€‚

* æˆ‘çš„é”®ä½è®¾ç½®
ç°åœ¨ vibe è¿™ä¹ˆæ–¹ä¾¿äº†ï¼Œä¸ºä»€ä¹ˆè¿˜è¦åœ¨è¿™ä¸ªä¸Šé¢èŠ±è¿™ä¹ˆå¤šå¿ƒæ€ï¼Ÿæˆ‘è§‰å¾—ç”¨é”®ç›˜æ‰“å­— coding å’Œå¼¹å‰ä»–çš„æ„Ÿè§‰å¾ˆåƒã€‚åœ¨ Emacs é‡Œé…ç½®è¿™äº›é”®ä½å¯¹æˆ‘æ¥è¯´ï¼Œå°±åƒåœ¨è°ƒç´å¼¦ï¼Œè°ƒåˆæˆå™¨ä¸€æ ·ã€‚vibe æ›´å¤šçš„æ˜¯äº«å—ç»“æœï¼Œè€Œè¿™äº›åˆ™æ˜¯äº«å—è¿‡ç¨‹ã€‚

æŒ‰é”®çš„è®¾ç½®å’Œè®¾è®¡ï¼Œå¾€å¤§äº†è¯´ï¼Œè¿™äº›é”®ä½çš„æ˜ å°„ä¹Ÿæ˜¯ä¸ªäººçš„æ€ç»´å’Œé€»è¾‘ä¹ æƒ¯çš„æ˜ å°„ã€‚ç¼–ç¨‹æ˜¯ä¸€ç§è¡¨è¾¾çš„è‰ºæœ¯ï¼Œç±»æ¯”ç»˜ç”»ï¼Œé”®ä½çš„ç¼–è¾‘å™¨è®¾ç½®å°±æ˜¯ç”»ç¬”ç¬”è§¦çš„ä¸ªäººè‰ºæœ¯é£æ ¼ã€‚

å¯¹äºç¼–è¾‘ä»£ç çš„äººæ¥è¯´ï¼Œè¿™äº›å¿«æ·é”®è®¾ç½®å°±åƒä¸€ä¸ªæå½±åƒç¼–è¾‘çš„äººçš„ Photoshop çš„è‡ªå®šä¹‰åŠ¨ä½œä¸€æ ·ï¼Œæ¯ä¸ªäººéƒ½æœ‰è‡ªå·±çš„æ€ç»´ä¹ æƒ¯å’Œæ“ä½œä¹ æƒ¯ã€‚è®©ä¸€ä¸ªç¨‹åºå‘˜å¤±å»ç¼–ç¨‹èƒ½åŠ›åªéœ€è¦ä¸€æ­¥ï¼šæ¢æ‰ä»–çš„é”®ç›˜ï¼Œç„¶åé…ç½®å¦ä¸€ä¸ªäººçš„æŒ‰é”®é…ç½®ğŸ¤£ ã€‚

æ‰€ä»¥åé¢ä¹Ÿåªæ˜¯ç®€å•è¯´æ˜ä¸€äº›é…ç½®æŒ‰é”®ç”¨åˆ°çš„ Emacs åŒ…å’Œé”®ä½è®¾ç½®çš„æ€è·¯ã€‚

Why emacs not vim? åªæ˜¯å› ä¸ºæ›´ä¹ æƒ¯ Emacs äº†ï¼Œè¿™äº›åœ¨ vim å’Œ Nvim é‡ŒåŒæ ·å¯ä»¥ã€‚

** General

é™¤å» vim æ¨¡å¼å’Œ Emacs æœ¬èº«å ç”¨çš„é”®ä½ï¼Œå¯ä»¥è‡ªå®šä¹‰çš„å…¶å®ä¸å¤šï¼Œæˆ‘è§‰å¾—æ¯”è¾ƒåˆé€‚çš„æ˜¯ ~m~ , ~r~ , ~,~ , ~.~ , ~/~ , ~;~ , ~'~ , ~[~ , ~]~

å®ƒä»¬æ—¢å¯ä»¥ä½œä¸º leader key ï¼Œè¿˜å¯ä»¥å’Œ Ctrl ç­‰é™„åŠ é”®ä½œä¸ºç»„åˆé”®ã€‚Emacs å’Œ vim é‡Œå®ƒä»¬éƒ½æ²¡æœ‰ç»‘å®šå¾ˆæ ¸å¿ƒçš„åŠŸèƒ½æˆ–æ˜¯ç©ºç¼ºçš„è®¾ç½®ã€‚

åœ¨ Emacs çš„å¿«æ·é”®è®¾ç½®é‡Œ Ctrl è®°ä½œ Cï¼ŒAlt å’Œ Option è®°ä½œ Mï¼ŒShift è®°ä½œ Sï¼ŒWin å’Œ Command è®°ä½œ s(super é”®)ï¼Œç»„åˆé”®ç”¨ ~-~ é“¾æ¥èµ·æ¥ï¼Œctrl+c è®°ä½œ ~C-c~ ã€‚

ç°åœ¨é…ç½®äº† m ä½œä¸º mark çš„ leader keyã€‚Emacs é‡Œçš„ mark ç›¸å½“äº vim é‡Œçš„ visual æ¨¡å¼ã€‚ä½†æ˜¯ Emacs é»˜è®¤çš„ mark é”®ä½æˆ‘å¾ˆä¸ä¹ æƒ¯ï¼Œvim é‡Œ visual æ¨¡å¼å¿«é€Ÿé€‰æ‹© symbolï¼Œwordï¼Œsentence ä¸­è‹±æ··åˆå†åŠ ä¸Šä»£ç åˆå¾ˆä¸æ–¹ä¾¿ã€‚æŠŠ m ç»‘å®šåœ¨äº† Emacs çš„ ~mark-sexp~ ä¸Šï¼Œç°åœ¨ mm å°±å¯ä»¥è¿ç»­ mark äº†ã€‚

vim é‡Œçš„ fï¼Œwï¼Œeï¼Œbï¼Œå†åŠ ä¸Š Emacs é‡Œè‡ªå¸¦çš„ ~forward-sexp~ , ~backward-sexp~ ,åœ¨ä»£ç è¡Œå†…çš„ç§»åŠ¨å°±å¾ˆæ–¹ä¾¿äº†ã€‚

æƒ³è¿‡å…¶ä»–è®¸å¤šæ–¹å¼æ¥å‡å°‘ vim æ¨¡å¼åˆ‡æ¢çš„æ“ä½œï¼Œä½†æ˜¯å®é™…ä½“éªŒä¸‹æ¥è¿˜æ˜¯å¤šåˆ‡æ¢æ›´çœäº‹ã€‚ç§»åŠ¨çš„æ—¶å€™è¿˜æ˜¯é€€å›åˆ° normalï¼Œæå°‘æ•°æƒ…å†µä¸‹ä¹Ÿç”¨ Ctrl ç»„åˆé”®åœ¨ insert æ¨¡å¼ä¸‹ç§»åŠ¨å…‰æ ‡ã€‚

åœ¨è¿™å‡ å¹´çš„ä½¿ç”¨ä¸­ï¼Œé€æ¸å½¢æˆäº†ä¸‹é¢çš„è¿™äº›æŒ‰é”®é…ç½®å’Œä¹ æƒ¯ã€‚æˆ‘å¾ˆè®¨åŒ evil é‡Œå¾ˆå¤šé»˜è®¤è‡ªå¸¦çš„å¿«æ·é”®ï¼Œæ‰€ä»¥èƒ½å–æ¶ˆçš„éƒ½å–æ¶ˆäº†ã€‚æ„Ÿè§‰è¿™äº›å¿«æ·é”®çš„è®¾ç½®ä¸Šè¿˜æ˜¯æ¯”è¾ƒç¬¦åˆç›´è§‰çš„ã€‚

ä¸‹é¢æ˜¯ä¸€äº›å…·ä½“çš„é…ç½®ç‰‡æ®µå’Œå¸¸ç”¨çš„è‡ªå®šä¹‰åŠŸèƒ½:

** mark & move
åŒ…å«äº†è®¾å®š mark æ–¹ä¾¿åœ¨ä»£ç ç¼–è¾‘é‡Œæ¥å›è·³è½¬ï¼Œdefunï¼Œsymbolï¼Œword çš„å¿«é€Ÿå¤åˆ¶å‰ªåˆ‡ã€‚

#+begin_src elisp
;; https://github.com/VandeeFeng/emacs.d/blob/archlinux/lisp/init-editing-utils.el
;; Mark & edit
(global-set-key (kbd "M-m") 'set-mark-command)

(with-eval-after-load 'evil
  (define-prefix-command 'my/mark-map)
  (define-key evil-normal-state-map (kbd "m") 'my/mark-map)
  (define-key evil-motion-state-map (kbd ";") nil)
  (evil-define-key '(normal visual) 'global
    "gc" #'comment-dwim)

  ;; this keybindings only use not in insert mode
  (dolist (binding '(("m" . mark-sexp)
                     ("p" . set-pin-mark) ; è¿™æ˜¯è‡ªå·±å®ç°çš„ init-mark.el
                     ("g" . goto-pin-mark) ; ç®€åŒ–ç‰ˆçš„ bookmark
                     ("d" . mark-defun)
                     (";" . comment-indent)
                     ;; (";" . comment-dwim) ; use gc instead
                     ("k" . move-dup-move-lines-up)
                     ("j" . move-dup-move-lines-down)
                     ("u" . upcase-dwim) ; equal to g U in vim
                     ("s" . thing-copy-symbol)
                     ("S" . thing-cut-symbol)
                     ("w" . thing-copy-word)
                     ("W" . thing-cut-word)
                     ("-" . thing-copy-to-line-end)
                     ("_" . thing-cut-to-line-end)
                     ("0" . thing-copy-to-line-beginning)
                     (")" . thing-cut-to-line-beginning)))
    (define-key my/mark-map (kbd (car binding)) (cdr binding)))
  )

(with-eval-after-load 'evil
  ;; normal, visual, insert
  (dolist (binding '(("C-s" . backward-kill-sexp)
                     ("C-S-s" . kill-back-to-indentation)
                     ("C-d" . kill-sexp)
                     ("C-k" . kill-visual-line)
                     ("C-y" . clipboard-yank)
                     ("C-a" . beginning-of-line)
                     ("C-e" . end-of-line)
                     ("C-b" . backward-char) ;; è¦†ç›– evil çš„é”®ä½ï¼Œå›å½’ Emacs é»˜è®¤é”®ä½
                     ("C-f" . forward-char) ;; è¦†ç›– evil çš„é”®ä½ï¼Œå›å½’ Emacs é»˜è®¤é”®ä½
                     ("C-n" . next-line) ;; è¦†ç›– evil çš„é”®ä½ï¼Œå›å½’ Emacs é»˜è®¤é”®ä½
                     ("C-p" . previous-line) ;; è¦†ç›– evil çš„é”®ä½ï¼Œå›å½’ Emacs é»˜è®¤é”®ä½
                     ))
    (dolist (state '(normal visual insert))
      (evil-global-set-key state (kbd (car binding)) (cdr binding))))

  ;; ;; visual, insert
  ;; (dolist (binding '(("C-h" . backward-char)
  ;;                    ("C-l" . forward-char)
  ;;                    ("C-j" . next-line)
  ;;                    ("C-k" . previous-line)))
  ;;   (dolist (state '(visual insert))
  ;;     (evil-global-set-key state (kbd (car binding)) (cdr binding))))

  ;; normal visual
  (dolist (binding '(("-" . end-of-line)
                     ("<" . beginning-of-defun)
                     (">" . end-of-defun)
                     ("," . backward-sexp)
                     ("." . forward-sexp)
                     ))
    (dolist (state '(normal visual))
      (evil-global-set-key state (kbd (car binding)) (cdr binding))))

  (define-key evil-motion-state-map (kbd "C-v") nil)
  (global-unset-key (kbd "C-v"))
  (global-set-key (kbd "S-<backspace>") 'delete-char))
#+end_src

** hydra & general
ç”±äºæˆ‘ä½¿ç”¨ evilï¼Œè®¾ç½® leader key è¿˜æ˜¯ç”¨çš„ generalï¼Œä½†æ˜¯æœ€è¿‘æŠŠæŒ‰é”®çš„è®¾ç½®è½¬åˆ°äº† hydraï¼Œå› ä¸ºå®ƒå¯ä»¥æ ¹æ®ä¸åŒçš„ Emacs çš„ major mode æ˜¾ç¤ºä¸åŒçš„ hydra key bodyã€‚åŒæ ·ä¸€ä¸ªè§¦å‘é”®ï¼Œåœ¨ org mode é‡Œå¯ä»¥æ˜¾ç¤º org çš„å¿«æ·é”®è®¾ç½®ï¼Œåœ¨ä¸åŒçš„ç¼–ç¨‹è¯­è¨€ mode é‡Œå¯ä»¥ä¸“é—¨çš„å¿«æ·é”®ã€‚

æˆ‘æœ‰æ—¶å€™ä¹Ÿç”¨ Nvimï¼Œæ‰€ä»¥è¿˜æ˜¯ç”¨ SPC ä½œä¸º leader keyï¼š

#+begin_src elisp
;; https://github.com/VandeeFeng/emacs.d/blob/archlinux/lisp/init-hydra.el
;; general è®¾ç½® leader key SPC
(general-define-key
 :states '(normal motion visual)
 :keymaps 'override
 :prefix "SPC"
 "" '(hydra-leader/body :wk "hydra leader"))

;; ä¸åŒæ¨¡å¼çš„å¸¸ç”¨å¿«æ·é”®è®¾ç½®
;; Mode-specific hydra bindings
(define-key evil-normal-state-map (kbd "C-.") nil)
(defun hydra-mode-setup ()
  "Setup hydra bindings for specific modes."
  (cond
   ((eq major-mode 'dired-mode)
    (local-set-key (kbd "C-.") 'hydra-dired/body))

   ((eq major-mode 'org-mode)
    (local-set-key (kbd "C-.") 'hydra-org/body))

   ((eq major-mode 'magit-status-mode)
    (local-set-key (kbd "C-.") 'hydra-magit/body))

   ((derived-mode-p 'prog-mode)
    (local-set-key (kbd "C-.") 'hydra-code/body))))

;; Add mode-specific setup to hooks
(add-hook 'dired-mode-hook 'hydra-mode-setup)
(add-hook 'org-mode-hook 'hydra-mode-setup)
(add-hook 'magit-status-mode-hook 'hydra-mode-setup)
(add-hook 'prog-mode-hook 'hydra-mode-setup)

#+end_src

** Misc
å…¶ä»–è‡ªå®šä¹‰å‡½æ•°åœ¨ï¼šhttps://github.com/VandeeFeng/emacs.d/blob/archlinux/lisp/init-custom-functions.el

jk é€€å‡º insertï¼š

#+begin_src elisp
;; jk é€€å‡º insert
(with-eval-after-load 'evil
  (use-package key-chord
    :ensure t
    :config
    (key-chord-mode 1)
    (setq key-chord-two-keys-delay 0.3) ;; ç‰ˆæœ¬æ›´æ–°ä¹‹åï¼Œé»˜è®¤j k çš„åˆ¤æ–­æ—¶é—´å˜å°‘äº†
    (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)))
#+end_src

compile grep searchï¼š

è¿™æ˜¯æˆ‘ç”¨çš„æœ€å¤šçš„ä¸€ä¸ªæœç´¢ã€‚å¯ä»¥ç”¨ grep æœç´¢å½“å‰æ–‡ä»¶ç›®å½•ä¸‹å…³é”®å­—ã€‚ç”¨ Emacs é‡Œçš„ compile æ¨¡å¼çš„å¥½å¤„æ˜¯ï¼Œå®ƒä¼šåœ¨æœç´¢ç»“æœçš„ minibuffer é‡Œæ˜¾ç¤ºå¯¹åº”çš„æ–‡ä»¶çš„è·³è½¬é“¾æ¥ï¼Œç›´æ¥ç‚¹å‡»å°±è·³è½¬äº†ã€‚

#+begin_src elisp
;; compile grep
(defun my/compile-grep-rn (pattern)
  "Run `grep -irn` with the given PATTERN in the current directory."
  (interactive "sGrep pattern: ")
  (compile (format "grep -irn '%s' ." pattern)))
#+end_src


org-backlink:

åŒæ ·ä¹Ÿæ˜¯ç”¨ grep æœç´¢å½“å‰ org ç¬”è®°çš„åé“¾

#+begin_src elisp

(defun my/org-backlink ()
  "Find all org files in the current directory that link to the current file.
The search is performed using `rgrep` for the specific pattern
'filename.org][filename]]'."
  (interactive)
  (unless buffer-file-name
    (error "Current buffer is not visiting a file"))

  (let* ((current-file (file-name-nondirectory buffer-file-name))
         (current-dir (file-name-directory buffer-file-name))
         (file-basename (file-name-sans-extension current-file))
         ;; Search for the literal string "filename.org][filename]]"
         (search-pattern (concat (regexp-quote current-file)
                                 "\\]\\["
                                 (regexp-quote file-basename)
                                 "\\]\\]")))
    (rgrep search-pattern "*.org" current-dir)))
#+end_src

simple claude:

ä½¿ç”¨ shellï¼Œå¿«é€Ÿè¿è¡Œ Claude Code æ‰§è¡Œ ~claude -p~ æŒ‡ä»¤å›ç­”ä¸€äº›ç®€å•çš„é—®é¢˜ï¼ŒæŠŠç»“æœè¾“å‡ºåˆ°å•ç‹¬çš„ bufferã€‚æœ‰æ—¶å€™ä¸æƒ³ç”¨ gptel å°±ç”¨è¿™ä¸ªã€‚å¯ä»¥æ›¿æ¢æˆ Gemini å’Œ Codexã€‚

#+begin_src elisp
;; simple claude code shell command
(defun my/claude-shell-command (prompt)
  "Execute claude command asynchronously and display the output."
  (interactive "sClaude prompt: ")
  (let* ((output-buffer-name "*Claude Output*")
         (output-buffer (get-buffer-create output-buffer-name))
         (shell-program (or (getenv "SHELL") shell-file-name))
         ;; Use shell-quote-argument
         (command-str (format "claude -p %s" (shell-quote-argument prompt))))
    (with-current-buffer output-buffer
      (setq buffer-read-only nil)
      (erase-buffer)
      (setq-local header-line-format (format "Claude Output for prompt: %s" prompt)))
    ;; (display-buffer output-buffer) ; Show the buffer immediately
    (message "Claude command running asynchronously...")
    ;; Start the async process
    (let ((process (start-process "claude-process"
                                  output-buffer-name
                                  shell-program
                                  "-lc"
                                  command-str)))
      ;; Set a function to be called when the process finishes
      (set-process-sentinel process #'my/claude-process-sentinel))))

(defun my/claude-process-sentinel (process _event)
  "Sentinel for the claude async process. Handles success and error cases."
  (when (memq (process-status process) '(exit signal))
    (let* ((buffer (process-buffer process))
           (exit-code (process-exit-status process)))
      (cond
       ;; Case 1: Process failed (non-zero exit code)
       ((/= exit-code 0)
        (kill-buffer buffer)
        (if (= exit-code 127)
            (message "Error: 'claude' command not found. Please ensure it's in your shell's PATH.")
          (message "Error: Claude command failed with exit code %d." exit-code)))

       ;; Case 2: Process succeeded but produced no output
       ((zerop (with-current-buffer buffer (buffer-size)))
        (kill-buffer buffer)
        (message "Claude command finished with no output."))

       ;; Case 3: Success
       (t
        (with-current-buffer buffer
          (setq buffer-read-only t)
          (goto-char (point-min)))
        (display-buffer buffer)
        (message "Claude command finished."))))))

#+end_src
