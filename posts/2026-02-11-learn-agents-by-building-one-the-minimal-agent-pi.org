#+title: Learn Agents by Building One: The Minimal Agent pi
#+date: <2026-02-11 11:58>
#+description: å¤§é“è‡³ç®€ï¼Œè¿™å¤§æ¦‚æ˜¯ Scaling Law ä¹‹åï¼Œagent é¢†åŸŸç°åœ¨çš„æ–°é“å¾‹äº†ã€‚
#+filetags: LLM

è¿™æ®µæ—¶é—´å°é¾™è™¾ OpenClaw çªç„¶å°±ç—…æ¯’å¼çš„çˆ†ç«äº†ï¼Œå®ƒèƒŒåçš„ agent æ¡†æ¶å°±æ˜¯ [[https://github.com/badlogic/pi-mono][pi-mono]].

[[https://mariozechner.at/posts/2025-11-30-pi-coding-agent/][What I learned building an opinionated and minimal coding agent]] pi-mono ä½œè€…çš„è¿™ç¯‡ blog è¯¦ç»†è§£é‡Šäº†ä»–æ„å»º pi-mono çš„åˆè¡·å’Œæ€è·¯ã€‚

å¤§é“è‡³ç®€ï¼Œè¿™å¤§æ¦‚æ˜¯ Scaling Law ä¹‹åï¼Œagent é¢†åŸŸç°åœ¨çš„æ–°é“å¾‹äº†ã€‚

* Pi-mono
pi-mono çš„ agent è®¾è®¡çš„æä¸ºç®€æ´ï¼šåªæœ‰ readï¼Œbashï¼Œeditï¼Œwrite å››ä¸ªåŸºç¡€å·¥å…·ï¼Œsystem prompt ä¹Ÿè®¾è®¡çš„éå¸¸ç®€æ´ã€‚AI agent â‰ˆ Tools + loops.

#+begin_src
You are an expert coding assistant. You help users with coding tasks by reading files, executing commands, editing code, and writing new files.

Available tools:
- read: Read file contents
- bash: Execute bash commands
- edit: Make surgical edits to files
- write: Create or overwrite files

Guidelines:
- Use bash for file operations like ls, grep, find
- Use read to examine files before editing
- Use edit for precise changes (old text must match exactly)
- Use write only for new files or complete rewrites
- When summarizing your actions, output plain text directly - do NOT use cat or bash to display what you did
- Be concise in your responses
- Show file paths clearly when working with files

Documentation:
- Your own documentation (including custom model setup and theme creation) is at: /path/to/README.md
- Read it when users ask about features, configuration, or setup, and especially if the user asks you to add a custom model or provider, or create a custom theme.
#+end_src

åœ¨å¤§è¯­è¨€æ¨¡å‹çš„èƒ½åŠ›è¶Šæ¥è¶Šå¼ºä¹‹åï¼Œç®€æ´çš„ prompt åè€Œå¯ä»¥å‘æŒ¥æ›´å¥½çš„æ•ˆæœã€‚ä»¥å‰æ¨¡å‹èƒ½åŠ›ä¸è¶³ï¼Œæ‰€ä»¥éœ€è¦è¯¦ç»†çš„ prompt æ¥æŒ‡å¯¼ agentï¼Œç°åœ¨åè¿‡æ¥äº†ï¼Œæ¨¡å‹èƒ½åŠ›å¾ˆå¼ºï¼Œåªéœ€è¦æä¾›ç®€æ´çš„ guide rulesï¼Œè®© agent èƒ½å¤Ÿè‡ªä¸»å‘æŒ¥ã€‚æˆ‘è§‰å¾—è¿™æ˜¯ pi-mono èƒ½å¤Ÿåœ¨ç°æœ‰æ¨¡å‹åŸºç¡€ä¸Šå®ç°å¾ˆå¥½çš„æ‰§è¡Œæ•ˆæœï¼Œå¾ˆé‡è¦çš„ä¸€ä¸ªåŸå› ã€‚

æ²¡æƒ³åˆ°ï¼ŒKISSåŸåˆ™ï¼ˆKeep It Simple, Stupidï¼‰ï¼ŒUnix ç³»ç»Ÿçš„ä¸€åˆ‡çš†æ˜¯æ–‡ä»¶çš„è®¾è®¡å“²å­¦ç°åœ¨ä¹Ÿæ·±æ·±çš„å½±å“äº† agent çš„èƒ½åŠ›ã€‚ç°é˜¶æ®µè®­ç»ƒå‡ºæ¥çš„æ¨¡å‹ï¼Œå¤©ç„¶çš„å°±ä¼šå¯¹æ–‡ä»¶æ“ä½œæ¯”è¾ƒç†Ÿæ‚‰ï¼ŒLLM æ›´å–œæ¬¢è¿™äº›åŸºç¡€çš„ shell æŒ‡ä»¤ï¼Œæ›´å–œæ¬¢å’Œæ–‡ä»¶æ‰“äº¤é“ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ Claude Code æ”¾å¼ƒä½¿ç”¨ Cursor çš„ RAG æ–¹æ¡ˆï¼Œè€Œä½¿ç”¨ grep æ¥è®© agent ç›´æ¥æœç´¢å’ŒæŸ¥æ‰¾æ–‡ä»¶ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ AGENTS.md æœ€ç»ˆä½¿ç”¨ md è¿™ä¸ªæ ¼å¼æ–‡æœ¬æ¥ä½œä¸º agent çš„æŒ‡å¯¼æ–‡ä»¶ã€‚

[[https://lucumr.pocoo.org/2026/1/31/pi/][Pi: The Minimal Agent Within OpenClaw | Armin Ronacher's Thoughts and Writings]] pi-mono æä¾›äº†éå¸¸æ–¹ä¾¿çš„ extension æ‰©å±•ç³»ç»Ÿï¼Œèƒ½å¤Ÿè°ƒç”¨ API å®ç°é«˜åº¦è‡ªå®šä¹‰çš„åŠŸèƒ½ï¼Œè¿™å®åœ¨æ˜¯ awesomeï¼

æ¯”èµ·é‚£äº›å¤æ‚çš„ agent æ¡†æ¶ï¼Œå„ç§æ¦‚å¿µã€è®ºæ–‡å’Œå¤æ‚çš„æŠ½è±¡å±‚ï¼Œpi-mono å¯¹æ–°æ‰‹æ¥è¯´æ˜¯åœ¨å¤ªå‹å¥½äº†ï¼Œæºç é‡Œè¿˜æœ‰å¤§é‡çš„ example å’Œ docsã€‚

ä» Claude Code åˆ° OpenCodeï¼Œå†åˆ° OpenClaw å’Œ pi-monoï¼Œæˆ‘è§‰å¾—ï¼Œæœ¬åœ°è‡ªéƒ¨ç½²æ¨¡å‹+è‡ªå®šä¹‰ agent ä¸€å®šæ˜¯æœªæ¥çš„è¶‹åŠ¿ã€‚äººäººéƒ½èƒ½å¤Ÿæœ‰ä¸€ä¸ªè‡ªå·±è‡ªå®šä¹‰ç‰ˆæœ¬çš„ AI agentï¼Œæœ€åå˜æˆä¸€ä¸ª USB å³æ’å³ç”¨ã€‚

* Pi-mono Extension
å‰æ®µæ—¶é—´åˆšå¼€å§‹æ·±å…¥ä¸€ç‚¹æŠ˜è…¾å’Œçœ‹ OpenCode çš„æºç ï¼Œæƒ³å®ç°ä¸€äº›è‡ªå®šä¹‰çš„åŠŸèƒ½ï¼Œä½†æ˜¯è¿™ä¸ªé¡¹ç›®å·²ç»åšçš„å¤ªå¤§äº†ï¼Œpi-mono æ›´é€‚åˆä¸ªäººæŠ˜è…¾ã€‚

** Command Rule
pi-mono æ²¡æœ‰å¯¹ tool è°ƒç”¨çš„è§„åˆ™è®¾å®šï¼Œå‚è€ƒ OpenCode çš„å®ç° è®© pi ç”Ÿæˆäº†ä¸€ä¸ª extension æ¥ç¦æ­¢ä¸€äº› shell æŒ‡ä»¤çš„è°ƒç”¨ï¼Œä¾‹å¦‚ rmï¼Œgit pushï¼Œgit commit:

#+begin_src typescript
/**
 * Command Permissions Extension
 *
 * Ported from opencode command permissions configuration.
 * Supports wildcard patterns and ask/allow/deny actions.
 *
 * Configuration in settings.json:
 * {
 *   "permission": {
 *     "YOLO": true,
 *     "nonInteractiveAsk": "deny",
 *     "read": { ".env": "deny", "*.md": "allow" },
 *     "bash": { "git push *": "ask", "rm -rf *": "deny" }
 *   }
 * }
 *
 * Config files (merged, project takes precedence):
 * - ~/.pi/agent/settings.json (global)
 * - <cwd>/.pi/settings.json (project-local)
 */

import { existsSync, readFileSync } from "node:fs";
import { homedir } from "node:os";
import { join } from "node:path";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

// Simple glob-to-regex converter for command matching
// Matches opencode's wildcard implementation
// * matches any characters (including /)
// ? matches any single character
// Pattern ending with " *" makes trailing part optional
function globToRegex(pattern: string): RegExp {
    let escaped = pattern
        .replace(/[.+^${}()|[\]\\]/g, '\\$&') // escape special regex chars
        .replace(/\*/g, '.*') // * becomes .*
        .replace(/\?/g, '.'); // ? becomes .

    // If pattern ends with " *" (space + wildcard), make the trailing part optional
    // This allows "ls *" to match both "ls" and "ls -la"
    if (escaped.endsWith(' .*')) {
        escaped = escaped.slice(0, -3) + '( .*)?';
    }

    return new RegExp(`^${escaped}$`, 's'); // 's' flag: . matches newlines
}

function minimatch(str: string, pattern: string): boolean {
    return globToRegex(pattern).test(str);
}

const DEFAULT_YOLO = true;
const DEFAULT_NON_INTERACTIVE_ASK: "allow" | "deny" = "deny";
const VALID_ACTIONS = ["ask", "allow", "deny"] as const;
type Action = (typeof VALID_ACTIONS)[number];

interface PermissionRule {
    pattern: string;
    action: Action;
    isWildcard: boolean;
}

interface PermissionConfig {
    permission?: {
        YOLO?: boolean;
        nonInteractiveAsk?: "allow" | "deny";
        read?: Record<string, string>;
        bash?: Record<string, string>;
        write?: Record<string, string>;
        edit?: Record<string, string> | string;
        grep?: Record<string, string> | string;
        find?: Record<string, string> | string;
        ls?: Record<string, string> | string;
        glob?: Record<string, string> | string;
        list?: Record<string, string> | string;
        [key: string]: Record<string, string> | string | boolean | undefined;
    };
}

// Tool config mapping (handles aliases)
const TOOL_CONFIGS: Array<{
    tools: string[];
    aliases: string[];
    getInput: (input: any) => string;
}> = [
    { tools: ["read"], aliases: [], getInput: (i) => i.path },
    { tools: ["bash"], aliases: [], getInput: (i) => i.command },
    { tools: ["write"], aliases: [], getInput: (i) => i.path },
    { tools: ["edit"], aliases: [], getInput: (i) => i.path },
    { tools: ["grep"], aliases: ["glob"], getInput: (i) => i.pattern },
    { tools: ["find"], aliases: [], getInput: (i) => i.pattern },
    { tools: ["ls"], aliases: ["list"], getInput: (i) => i.path || "." },
];

function loadSettings(cwd: string): PermissionConfig {
    const loadFile = (path: string) => {
        if (!existsSync(path)) return {};
        try {
            const content = readFileSync(path, "utf-8");
            const parsed = JSON.parse(content);
            return parsed.permission || {};
        } catch (err) {
            console.error(`Failed to load permissions from ${path}: ${err}`);
            return {};
        }
    };

    const globalPerm = loadFile(join(homedir(), ".pi", "agent", "settings.json"));
    const projectPerm = loadFile(join(cwd, ".pi", "settings.json"));

    return { permission: { ...globalPerm, ...projectPerm } };
}

function parseRules(config: Record<string, string> | string | undefined): PermissionRule[] {
    if (typeof config === "string") {
        return VALID_ACTIONS.includes(config as Action)
            ? [{ pattern: "*", action: config as Action, isWildcard: true }]
            : [];
    }

    if (!config || typeof config !== "object") return [];

    return Object.entries(config)
        .filter(([, action]) => VALID_ACTIONS.includes(action as Action))
        .map(([pattern, action]) => ({
            pattern,
            action: action as Action,
            isWildcard: pattern.includes("*") || pattern.includes("?"),
        }));
}

function matchInput(input: string, rules: PermissionRule[]): PermissionRule | null {
    const normalized = input.trim().replace(/\s+/g, " ");

    // Find the LAST matching rule (later rules override earlier ones, like opencode)
    const matchingRule = [...rules].reverse().find((r) => {
        if (!r.isWildcard) {
            return r.pattern === normalized;
        }
        return minimatch(normalized, r.pattern);
    });

    return matchingRule || null;
}

function splitCommands(command: string): string[] {
    const result: string[] = [];
    let current = "";
    let inSingle = false;
    let inDouble = false;
    let escape = false;

    for (let i = 0; i < command.length; i++) {
        const char = command[i];
        const next = command[i + 1];

        if (escape) {
            current += char;
            escape = false;
            continue;
        }

        if (char === "\\") {
            escape = true;
            current += char;
            continue;
        }

        if (char === "'" && !inDouble) { inSingle = !inSingle; current += char; continue; }
        if (char === '"' && !inSingle) { inDouble = !inDouble; current += char; continue; }

        if (!inSingle && !inDouble) {
            if (((char === "&" || char === "|") && next === char) || char === ";" || char === "|") {
                const trimmed = current.trim();
                if (trimmed) result.push(trimmed);
                current = "";
                if (next === char) i++;
                continue;
            }
        }

        current += char;
    }

    if (current.trim()) result.push(current.trim());
    return result;
}

export default function (pi: ExtensionAPI) {
    const rules = new Map<string, PermissionRule[]>();
    let yoloMode = DEFAULT_YOLO;
    let nonInteractiveAsk = DEFAULT_NON_INTERACTIVE_ASK;

    function loadPermissions(cwd: string) {
        const config = loadSettings(cwd).permission || {};
        yoloMode = config.YOLO ?? DEFAULT_YOLO;
        nonInteractiveAsk = config.nonInteractiveAsk ?? DEFAULT_NON_INTERACTIVE_ASK;

        TOOL_CONFIGS.forEach(({ tools, aliases }) => {
            const tool = tools[0];
            const toolConfig = tools.concat(aliases).reduce((acc, t) => ({
                ...acc,
                ...(config[t as keyof typeof config] || {}),
            }), {});

            rules.set(tool, parseRules(toolConfig as Record<string, string> | string));
        });
    }

    async function askPermission(message: string, ctx: any): Promise<boolean> {
        if (!ctx.hasUI) {
            return nonInteractiveAsk === "allow";
        }
        const choice = await ctx.ui.select(message, ["Yes", "No"]);
        return choice === "Yes";
    }

    async function checkPermission(
        toolName: string,
        input: string,
        toolRules: PermissionRule[],
        ctx: any,
    ): Promise<{ block: true; reason: string } | undefined> {
        const rule = matchInput(input, toolRules);

        if (!rule) {
            if (yoloMode) return undefined;
            const allowed = await askPermission(
                `âš ï¸ No permission rule for:\n\n  ${toolName}: ${input}\n\nAllow?`,
                ctx,
            );
            return allowed ? undefined : { block: true, reason: "Blocked by user" };
        }

        if (rule.action === "allow") return undefined;
        if (rule.action === "deny") return { block: true, reason: `Blocked by permission rules: ${toolName}` };

        const allowed = await askPermission(
            `âš ï¸ Permission required:\n\n  ${toolName}: ${input}\n\nAllow?`,
            ctx,
        );
        return allowed ? undefined : { block: true, reason: "Blocked by user" };
    }

    pi.on("session_start", async (_event, ctx) => loadPermissions(ctx.cwd));

    pi.on("tool_call", async (event, ctx) => {
        const { toolName, input } = event;

        const toolConfig = TOOL_CONFIGS.find((t) => t.tools.includes(toolName));
        if (!toolConfig) return undefined;

        const toolRules = rules.get(toolName) || [];
        const inputStr = toolConfig.getInput(input);

        // Special handling for bash compound commands
        if (toolName === "bash" && toolRules.length > 0) {
            const subCommands = splitCommands(inputStr);

            for (const subCmd of subCommands) {
                const rule = matchInput(subCmd, toolRules);
                if (!rule || rule.action === "allow") continue;

                if (rule.action === "deny") {
                    return { block: true, reason: `Blocked by permission rules: ${subCmd}` };
                }

                const display = subCommands.length > 1
                    ? `${subCmd}  (in: "${inputStr}")`
                    : inputStr;

                const allowed = await askPermission(
                    `âš ï¸ Permission required:\n\n  bash: ${display}\n\nAllow?`,
                    ctx,
                );
                if (!allowed) return { block: true, reason: "Blocked by user" };
            }
            return undefined;
        }

        // No rules configured
        if (toolRules.length === 0) {
            if (yoloMode) return undefined;
            const allowed = await askPermission(
                `âš ï¸ No permission rules for ${toolName}:\n\n  ${inputStr}\n\nAllow?`,
                ctx,
            );
            return allowed ? undefined : { block: true, reason: "Blocked by user" };
        }

        return checkPermission(toolName, inputStr, toolRules, ctx);
    });
}
#+end_src


** Subagent
pi çš„åŸå§‹è®¾è®¡ç†å¿µé‡Œï¼Œæ²¡æœ‰ subagentï¼Œæ‰€ä»¥ä¹Ÿå°±æ²¡æœ‰ @agent è¿™ç§å¿«é€Ÿè°ƒç”¨ subagent åœ¨ç‹¬ç«‹ä¸Šä¸‹æ–‡é‡Œè¿è¡Œå†è¿”å›ç»“æœç»™ä¸» agent çš„è®¾è®¡ã€‚

[[https://github.com/nicobailon/pi-subagents][Nicoâ€™s subagent extension]] , [[https://www.npmjs.com/package/pi-interactive-shell][interactive-shell]] è¿™ä¸¤ä¸ª pi çš„æ’ä»¶å®ç°äº†ç±»ä¼¼çš„åŠŸèƒ½ï¼Œä½†æ˜¯å¯¹æˆ‘æ¥è¯´æœ‰äº›å¤æ‚ã€‚

ç°é˜¶æ®µæˆ‘çš„æ–¹å¼å°±æ˜¯æ–°å¼€ä¸€ä¸ª tmux è¿”å›ä¸€ä¸ª tmux session çš„ txt æ–‡æœ¬è®°å½•å®Œæ•´çš„ LLM è¾“å‡ºã€‚

åœ¨ pi çš„ TUI é‡Œï¼Œé€šè¿‡ `/agent` æ¥è°ƒç”¨è¿™äº› subagentï¼Œå¹¶å®ç°äº†ä¸¤ä¸ªæ¨¡å¼ï¼šå½“å‰ä¼šè¯å’Œ tmux åå°è¿è¡Œã€‚

tmux çš„è¿è¡ŒçŠ¶æ€ä¼šåœ¨ TUI çš„ footer éƒ¨åˆ†æŒç»­æ˜¾ç¤ºã€‚ç›´æ¥ç”¨ tmux æŒ‡ä»¤å°±å¯ä»¥å’Œè¿™ä¸ª subagent session äº¤äº’äº†ã€‚åœ¨ subagent session å®Œæˆä¹‹åä¼šä½¿ç”¨ pi çš„ notify é€šçŸ¥æ˜¾ç¤º txt æ–‡æœ¬çš„è¾“å‡ºè·¯å¾„ï¼Œä¸» agent å°±å¯ä»¥é˜…è¯»äº†ã€‚

#+attr_html: :alt :class img :width 60% :height 60%
https://pic.vandee.art/images/20260211_125004-agent1.png

#+attr_html: :alt :class img :width 60% :height 60%
https://pic.vandee.art/images/20260211_125302-agent2.png

#+attr_html: :alt :class img :width 60% :height 60%
https://pic.vandee.art/images/20260211_125325-agent3.png

#+begin_src typescript
/**
 * Agents Select Extension
 *
 * Provides interactive agent selection and invocation via /agents command
 * and direct @agent-name invocation with task input.
 */

import * as fs from "node:fs";
import * as os from "node:os";
import * as path from "node:path";
import { exec } from "node:child_process";
import { spawn } from "node:child_process";
import { promisify } from "node:util";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { parseFrontmatter, DynamicBorder } from "@mariozechner/pi-coding-agent";
import { Container, Editor, Input, SelectList, Text, Spacer, matchesKey, Key, CombinedAutocompleteProvider } from "@mariozechner/pi-tui";

const execAsync = promisify(exec);

interface AgentConfig {
        name: string;
        description: string;
        source: "user" | "project";
        filePath: string;
        systemPrompt: string;
}

const USER_AGENTS_DIR = path.join(os.homedir(), ".pi", "agent", "agents");
const PROJECT_AGENTS_DIR_NAME = path.join(".pi", "agents");
const AGENT_FILE_EXTENSION = ".md";
const AGENT_NAME_PATTERN = /^@([a-zA-Z0-9_-]+)\s+(.+)$/s;
const PROCESS_STARTUP_WAIT_MS = 1500;
const STOPWORDS = new Set(["the", "for", "with", "from", "into"]);
const MAX_KEYWORDS = 3;
const MIN_KEYWORD_LENGTH = 3;

const TMUX_PI_SCRIPT = path.join(os.homedir(), ".pi/agent/skills/tmux-pi/scripts/run-pi-monitored.sh");

function generateSessionName(agentName: string, task: string): string {
        const cleanAgentName = agentName.replace(/^@/, "");
        const words = task
                .toLowerCase()
                .replace(/[^\w\s]/g, " ")
                .split(/\s+/)
                .filter((w) => w.length > MIN_KEYWORD_LENGTH && !STOPWORDS.has(w));
        const keywordStr = words.slice(0, MAX_KEYWORDS).join("-");
        return `pi-${cleanAgentName}-${keywordStr}`;
}

async function checkSessionExists(sessionName: string): Promise<boolean> {
        try {
                await execAsync(`tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -q "^${sessionName}$"`);
                return true;
        } catch {
                return false;
        }
}

async function runSubagentSession(
        agentName: string,
        task: string,
        cwd: string
): Promise<{ sessionName: string; outputFile: string }> {
        const sessionName = generateSessionName(agentName, task);
        const outputFile = `/tmp/pi-conversation-${sessionName}-${Date.now()}.txt`;
        const command = `@${agentName} ${task}`;

        const proc = spawn(
                "bash",
                [TMUX_PI_SCRIPT, "-n", sessionName, "-d", cwd, "-c", command, "-o", outputFile, "-v"],
                { detached: true, stdio: ["ignore", "pipe", "pipe"] }
        );

        proc.unref();
        proc.stderr?.on("data", function () {});

        await new Promise(function (resolve) {
                setTimeout(resolve, PROCESS_STARTUP_WAIT_MS);
        });

        try {
                process.kill(proc.pid as number, 0);
                return { sessionName, outputFile };
        } catch {
                throw new Error(`Process exited. Check /tmp/pi-startup-${sessionName}.log`);
        }
}

function loadAgentsFromDir(dir: string, source: "user" | "project"): AgentConfig[] {
        if (!fs.existsSync(dir)) {
                return [];
        }

        return fs.readdirSync(dir, { withFileTypes: true })
                .filter(function (entry) {
                        return entry.name.endsWith(AGENT_FILE_EXTENSION) && (entry.isFile() || entry.isSymbolicLink());
                })
                .map(function (entry) {
                        const filePath = path.join(dir, entry.name);
                        const { frontmatter, body } = parseFrontmatter<Record<string, unknown>>(fs.readFileSync(filePath, "utf-8"));

                        if (!frontmatter.name || !frontmatter.description) {
                                return null;
                        }

                        return {
                                name: String(frontmatter.name),
                                description: String(frontmatter.description),
                                source,
                                filePath,
                                systemPrompt: body.trim(),
                        };
                })
                .filter((config): config is AgentConfig => config !== null);
}

function findNearestProjectAgentsDir(cwd: string): string | null {
        let currentDir = cwd;

        while (currentDir !== path.dirname(currentDir)) {
                const candidate = path.join(currentDir, PROJECT_AGENTS_DIR_NAME);
                if (fs.existsSync(candidate)) {
                        return candidate;
                }
                currentDir = path.dirname(currentDir);
        }

        return null;
}

function discoverAgents(cwd: string): AgentConfig[] {
        const projectAgentsDir = findNearestProjectAgentsDir(cwd);
        const userAgents = loadAgentsFromDir(USER_AGENTS_DIR, "user");
        const projectAgents = projectAgentsDir ? loadAgentsFromDir(projectAgentsDir, "project") : [];

        const agentMap = new Map(userAgents.map((a) => [a.name, a]));
        projectAgents.forEach((a) => agentMap.set(a.name, a));

        return Array.from(agentMap.values());
}

const NAVIGATION_KEYS = [Key.up, Key.down, Key.enter, Key.escape];

export default function agentAtDiscovery(pi: ExtensionAPI): void {
        let activeAgent: AgentConfig | null = null;
        let cachedAgents: AgentConfig[] | null = null;
        let subagentTasks: Array<{ agentName: string; sessionName: string; outputFile: string; task: string; startTime: number; ctx: any }> = [];

        function formatElapsed(seconds: number): string {
                if (seconds < 60) {
                        return `${seconds}s`;
                }
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}m${remainingSeconds}s`;
        }

        function updateSubagentStatus(): void {
                if (subagentTasks.length === 0) {
                        return;
                }

                const task = subagentTasks[0];
                const elapsed = Math.floor((Date.now() - task.startTime) / 1000);
                const theme = task.ctx.ui.theme;
                const status = theme.fg("dim", `@${task.agentName} | tmux-session: ${task.sessionName} | â±ï¸ ${formatElapsed(elapsed)}`);
                task.ctx.ui.setWidget("subagent-status", [status], { placement: "belowEditor" });
        }

        const STATUS_CHECK_INTERVAL_MS = 5000;

        async function checkTaskStatus(): Promise<void> {
                const stillRunning: typeof subagentTasks = [];

                for (const task of subagentTasks) {
                        const sessionRunning = await checkSessionExists(task.sessionName);

                        if (!sessionRunning && fs.existsSync(task.outputFile)) {
                                task.ctx.ui.notify(`âœ“ Task completed: ${task.sessionName}`, "success");
                                task.ctx.ui.notify(`ğŸ“„ Results: ${task.outputFile}`, "info");
                                task.ctx.ui.setWidget("subagent-status", undefined);
                                continue;
                        }
                        stillRunning.push(task);
                }

                subagentTasks = stillRunning;
                updateSubagentStatus();

                if (subagentTasks.length > 0) {
                        setTimeout(checkTaskStatus, STATUS_CHECK_INTERVAL_MS);
                }
        }

        pi.on("session_start", async function (_event, ctx) {
                cachedAgents = discoverAgents(ctx.cwd);
                ctx.ui.notify(`Loaded ${cachedAgents.length} agents. Use /agents or @agent-name`, "info");
        });

        pi.on("before_agent_start", async function (event) {
                if (!activeAgent) {
                        return {};
                }
                const fullPrompt = event.systemPrompt + "\n\n" + activeAgent.systemPrompt;
                return { systemPrompt: fullPrompt };
        });

        pi.on("agent_end", async function () {
                activeAgent = null;
        });

        pi.registerCommand("agents", {
                description: "Select an agent and provide a task",
                handler: async function (_args, ctx) {
                        const agents = cachedAgents ?? discoverAgents(ctx.cwd);

                        if (agents.length === 0) {
                                ctx.ui.notify("No agents found. Create .md files in ~/.pi/agent/agents/ or .pi/agents/", "warning");
                                return;
                        }

                        const result = await ctx.ui.custom<{ agentName: string; task: string; subagentMode?: boolean } | null>(
                                function (tui, theme, _kb, done) {
                                        const searchInput = new Input();
                                        const accentBorder = (s: string) => theme.fg("accent", s);

                                        const selectListTheme = {
                                                selectedPrefix: accentBorder,
                                                selectedText: accentBorder,
                                                description: (t: string) => theme.fg("muted", t),
                                                scrollInfo: (t: string) => theme.fg("dim", t),
                                                noMatch: (t: string) => theme.fg("warning", t),
                                        };

                                        const editorTheme = { borderColor: accentBorder, selectList: selectListTheme };

                                        const taskInput = new Editor(tui, editorTheme, { paddingX: 1 });
                                        taskInput.setAutocompleteProvider(new CombinedAutocompleteProvider([], ctx.cwd, "fd"));

                                        const selectList = new SelectList(
                                                agents.map((a) => ({ value: a.name, label: a.name, description: a.description })),
                                                Math.min(agents.length, 10),
                                                selectListTheme
                                        );

                                        let selectedAgent: string | null = null;
                                        let showTaskInput = false;
                                        let subagentMode = false;

                                        selectList.onSelect = function (item) {
                                                selectedAgent = item.value;
                                                searchInput.setValue("");
                                                showTaskInput = true;
                                                tui.requestRender();
                                        };

                                        selectList.onCancel = function () {
                                                done(null);
                                        };

                                        const agentSelectionContainer = new Container();
                                        agentSelectionContainer.addChild(new DynamicBorder(accentBorder));
                                        agentSelectionContainer.addChild(new Text(theme.fg("accent", theme.bold("Select Agent")), 1, 0));
                                        agentSelectionContainer.addChild(searchInput);
                                        agentSelectionContainer.addChild(new Spacer(1));
                                        agentSelectionContainer.addChild(selectList);
                                        agentSelectionContainer.addChild(new Spacer(1));
                                        agentSelectionContainer.addChild(new Text(theme.fg("dim", "type to filter â€¢ â†‘â†“ navigate â€¢ enter select â€¢ esc cancel"), 1, 0));
                                        agentSelectionContainer.addChild(new DynamicBorder(accentBorder));

                                        const taskContainer = new Container();
                                        taskContainer.addChild(new DynamicBorder(accentBorder));
                                        taskContainer.addChild(new Text("", 1, 0));
                                        taskContainer.addChild(new Spacer(1));
                                        taskContainer.addChild(taskInput);
                                        taskContainer.addChild(new Spacer(1));
                                        taskContainer.addChild(new Text(theme.fg("dim", "@file autocomplete â€¢ ctrl+up toggle subagent â€¢ enter confirm â€¢ esc cancel"), 1, 0));
                                        taskContainer.addChild(new DynamicBorder(accentBorder));

                                        function updateTaskHeader(): void {
                                                const subagentState = subagentMode ? "ON" : "OFF";
                                                const subagentColor = subagentMode ? "success" : "dim";
                                                const header =
                                                        theme.fg("accent", theme.bold(`Task for @${selectedAgent}`)) +
                                                        " " +
                                                        theme.fg(subagentColor, theme.bold(`[Subagent: ${subagentState}]`));
                                                taskContainer.children[1] = new Text(header, 1, 0);
                                        }

                                        return {
                                                render(width: number) {
                                                        if (showTaskInput) {
                                                                updateTaskHeader();
                                                                return taskContainer.render(width);
                                                        }
                                                        return agentSelectionContainer.render(width);
                                                },
                                                invalidate() {
                                                        agentSelectionContainer.invalidate();
                                                        taskContainer.invalidate();
                                                        searchInput.invalidate();
                                                },
                                                handleInput(data: string) {
                                                        if (showTaskInput) {
                                                                if (matchesKey(data, Key.escape)) {
                                                                        showTaskInput = false;
                                                                        selectedAgent = null;
                                                                        taskInput.setText("");
                                                                        subagentMode = false;
                                                                } else if (matchesKey(data, Key.ctrl("up"))) {
                                                                        subagentMode = !subagentMode;
                                                                } else if (matchesKey(data, Key.enter)) {
                                                                        const task = taskInput.getText();
                                                                        if (task.trim()) {
                                                                                done({ agentName: selectedAgent!, task: task.trim(), subagentMode });
                                                                                return;
                                                                        }
                                                                } else {
                                                                        taskInput.handleInput(data);
                                                                }
                                                        } else {
                                                                const isNavKey = NAVIGATION_KEYS.some((k) => matchesKey(data, k));
                                                                if (isNavKey) {
                                                                        selectList.handleInput(data);
                                                                } else {
                                                                        searchInput.handleInput(data);
                                                                        selectList.setFilter(searchInput.getValue());
                                                                }
                                                        }
                                                        tui.requestRender();
                                                },
                                        };
                                }
                        );

                        if (!result) return;

                        const selectedAgentConfig = agents.find((a) => a.name === result.agentName);

                        if (!selectedAgentConfig) {
                                ctx.ui.notify(`Agent "${result.agentName}" not found`, "error");
                                return;
                        }

                        if (result.subagentMode) {
                                const sessionName = generateSessionName(selectedAgentConfig.name, result.task);

                                try {
                                        const { outputFile } = await runSubagentSession(selectedAgentConfig.name, result.task, ctx.cwd);
                                        subagentTasks.push({
                                                agentName: selectedAgentConfig.name,
                                                sessionName,
                                                outputFile,
                                                task: result.task,
                                                startTime: Date.now(),
                                                ctx,
                                        });
                                        updateSubagentStatus();

                                        if (subagentTasks.length === 1) {
                                                setTimeout(checkTaskStatus, STATUS_CHECK_INTERVAL_MS);
                                        }

                                        ctx.ui.notify(`ğŸ¤– Start agent @${selectedAgentConfig.name} for background task: ${sessionName}`, "success");
                                        return;
                                } catch (err: unknown) {
                                        const message = err instanceof Error ? err.message : "Unknown error";
                                        ctx.ui.notify(`âœ— Failed: ${message}`, "error");
                                        return;
                                }
                        }

                        activeAgent = selectedAgentConfig;
                        ctx.ui.notify(`ğŸ¤– Start agent @${selectedAgentConfig.name}`, "info");
                        pi.sendUserMessage(result.task, { deliverAs: "steer" });
                },
        });

        pi.on("input", async function (event, ctx) {
                if (event.source === "extension") {
                        return { action: "continue" };
                }

                const match = event.text.trim().match(AGENT_NAME_PATTERN);
                if (!match) {
                        return { action: "continue" };
                }

                const [, agentName, task] = match;
                const agents = cachedAgents ?? discoverAgents(ctx.cwd);
                const agent = agents.find((a) => a.name === agentName);

                if (!agent) {
                        ctx.ui.notify(`Unknown agent "@${agentName}". Use /agents to list available agents.`, "error");
                        return { action: "handled" };
                }

                activeAgent = agent;
                ctx.ui.notify(`Activating agent @${agentName}...`, "info");

                return { action: "transform", text: task };
        });
}
#+end_src
