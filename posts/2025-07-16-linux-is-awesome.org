#+title: Linux 太自由了
#+date: <2025-07-16 13:30>
#+description: AI 现在的发展趋势，更多的是资本的裹挟。它直接导致，如果不接入它，就会被市场淘汰。所以操作系统整合 AI 这个趋势，我很理解，如果以后它们单独推出不绑定 AI 的操作系统版本，我还是有可能会继续用。但是如果你把这些强行让消费者来买单，不给消费者选择，这是我反感的。PC 这个产品，或者说操作系统压根就和 AI 没有半毛钱必然的关系啊，为啥我要使用 PC 就一定要用 AI？这就好像我只是想骑自行车，但是必须要带上一个一直会在旁边 BB 的导航一样，我不需要给资本的这些运作买单。
#+filetags: Linux Ramble

* TL;DR
Linux 就是我从现在开始会一直使用下去的操作系统。它的太多设计理念和我不谋而合，Linus 有太多理念和我不谋而合。

* “不可避免的 AI”
从接触到个人电脑 PC 这个概念开始，就一直用的 Windows，直到很晚才开始使用 Mac，最初的原因也只是需要处理摄影的照片，Mac 的 M 芯片在刚出来的时候就是王炸。

之前我对操作系统一直没有什么概念，用着顺手，系统 UI 看着舒服就好了，对 PC 和操作系统也没有什么特殊的情怀和偏爱。但近几年，Windows 首先开始把 AI 功能整合到操作系统默认的系统服务里，这种趋势是我很反感的。要是很有用也就算了，隐私问题就更得不到保证，现在 Apple 也开始了。作为一个普通的消费者，如果产品里没有我可以选择的需求，不用就好了。

AI 现在的发展趋势，更多的是资本的裹挟。它直接导致，如果不接入它，就会被市场淘汰。所以操作系统整合 AI 这个趋势，我很理解，如果以后它们单独推出不绑定 AI 的操作系统版本，我还是有可能会继续用。但是如果你把这些强行让消费者来买单，不给消费者选择，这是我反感的。PC 这个产品，或者说操作系统压根就和 AI 没有半毛钱必然的关系啊，为啥我要使用 PC 就一定要用 AI？这就好像我只是想骑自行车，但是必须要带上一个一直会在旁边 BB 的导航一样，我不需要给资本的这些运作买单。几个巨头，大佬发发推，搞搞发布会，融融资，AI 就成了必然和必须，所谓的 AI 革命就开始了。

#+begin_quote
AI 就是一种新型的操作系统，帮你完成各种任务。这个系统的 CPU 就是大模型，内存就是模型的上下文窗口，窗口越大能完成的任务规模就越大。

-- [[https://rlancemartin.github.io/2025/06/23/context_engineering/][Andrej Karpathy]]，著名 AI 科学家
#+end_quote

我其实很期待根据上面 AK 大佬所构想的以 LLM 大语言模型为驱动的新操作系统，想想就挺有意思的：当 CPU 里直接集成了大语言模型模块之后，每次打开一个系统里的新窗口，它都可以动态的根据你短暂的操作历史、或是天气、心情，生成。这才是我觉得真正的 AI 整合到操作系统。

但AI 现在的形态最多只是一种更智能的自动化实现，距离真正的人工智能还有很远。

互联网发展到现在已经成为了一个普惠的基础服务设施，但 AI 现在还不是，对 AI 过度鼓吹的那些布道者所宣称的普惠性，到现在我还没有真正体会到。它们正在把 token 变成现在的网络流量一样，网络流量的付费那是基础服务设施的付费，AI 现在的 token 付费完全还只是产品的付费。工业革命不管怎么样，是完全把人类社会的生产力提高了一个层次，机器替代了许多重复性的人工劳动实现了自动化，AI 革命距离它提高生产力还有太远，现在还只是资本游戏的开头。解决不了能源问题，以 AI 现在的耗电量，我都怕撑不到 AI 革命正式开始的那一天。

[[https://tomrenner.com/posts/llm-inevitabilism/][The sound of inevitability]] 这个文章的观点挺好：

#+begin_quote
People advancing an inevitabilist world view state that the future they perceive will inevitably come to pass. It follows, relatively straightforwardly, that the only sensible way to respond to this is to prepare as best you can for that future.

持有不可避免主义世界观的人声称他们所感知的未来将不可避免地到来。相对简单地说，回应这一点的唯一明智方式就是尽可能为那个未来做好准备。

This is a fantastic framing method. Anyone who sees the future differently to you can be brushed aside as “ignoring reality”, and the only conversations worth engaging are those that already accept your premise.

这是一种绝妙的框架方法。任何与您看待未来不同的人都可以被视为“忽视现实”，而唯一值得参与的对话是那些已经接受您前提的对话。

I’m not convinced that LLMs are the future. I’m certainly not convinced that they’re the future I want. But what I’m most certain of is that we have choices about what our future should look like, and how we choose to use machines to build it.

我并不相信大型语言模型是未来。我当然不相信它们是我想要的未来。但我最确定的是，我们对未来应该是什么样子有选择权，以及我们选择如何使用机器来构建它。
#+end_quote

今年一直在看 C 语言，体验 C 语言最合适的操作系统当然就是 Linux 了。在虚拟机里许多底层的实验操作起来不是很方便，正好还有一个很老的电脑已经不能装 Win10 了，最开始是抱着试一试的想法，安装了 Arch Linux，没想到使用体验实在是太好了，一点不卡。选 Arch Linux 是因为它的 wiki 做的太好了，对于新手很友好，Arch 的自由度也很高。

再加上，Emacs 在 Linux 里才是满血的，现在所有的 workflow，除了 PS 处理照片和 ollama 的本地模型之外，都迁移到了这个老电脑 Arch Linux。

Mac 里的 Emacsclient 一直感觉怪怪的，在 Linux 里体验就很顺畅，打开 Emacsclient 也是秒开，和 Nvim 打开的速度一样快。

如果说上面的这些是让我开始使用 Linux 的诱因，那么 Linus 和 [[https://wiki.vandee.art/#%E3%80%8AJust%20For%20Fun%E3%80%8B][《Just For Fun》]] 这本书，就是让我会一直使用 Linux 的原因。Linus 开源 Linux 的这个决定实在是太伟大了。Linus 对于他实现的许多我看来很了不起的事情，只是很谦虚的表示：他在当时完全没有想到后面的事情，只是觉得自己对这些很感兴趣就做了，从结果来看就是自己一次次的走在了自己的前面。

Linux 这种自由的感觉很舒服。

* Arch Linux 配置记录
简单记录一下从 Mac 迁移到 Arch Linux 的配置。
** 脚本
让 LLM 随便弄了一个 Linux 的初始化脚本，安装一些我需要的软件和配置。

#+BEGIN_SRC bash

#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e

# Check if the script is run as root
if [ "$(id -u)" -ne 0 ]; then
  echo "This script must be run as root" >&2
  exit 1
fi

# --- Package Lists ---
BASE_PACKAGES="git curl neovim emacs vim feh mpv docker opensnitch"
FCITX5_PACKAGES_ARCH="fcitx5 fcitx5-rime fcitx5-chinese-addons fcitx5-configtool"
FCITX5_PACKAGES_UBUNTU="fcitx5 fcitx5-rime fcitx5-chinese-addons fcitx5-config-qt"
FCITX5_PACKAGES_FEDORA="fcitx5 fcitx5-rime fcitx5-chinese-addons fcitx5-configtool"
FCITX5_PACKAGES_SUSE="fcitx5 fcitx5-rime fcitx5-chinese-addons fcitx5-configtool"

# Function to install packages on Arch Linux
install_arch() {
  echo "Updating system..."
  pacman -Syu --noconfirm --needed
  echo "Installing packages for Arch..."
  for pkg in $BASE_PACKAGES $FCITX5_PACKAGES_ARCH base-devel; do
    pacman -S --noconfirm --needed "$pkg" || echo "Skipping '$pkg': not found or error."
  done
}

# Function to install packages on Ubuntu/Debian
install_ubuntu() {
  echo "Updating system..."
  apt-get update
  echo "Installing packages for Debian/Ubuntu..."
  apt-get install -y --ignore-missing $BASE_PACKAGES $FCITX5_PACKAGES_UBUNTU docker.io build-essential
}

# Function to install packages on Fedora
install_fedora() {
  echo "Installing packages for Fedora..."
  for pkg in $BASE_PACKAGES $FCITX5_PACKAGES_FEDORA; do
    dnf -y install "$pkg" || echo "Skipping '$pkg': not found or error."
  done
  echo "Installing development tools for Fedora..."
  dnf -y groupinstall "C Development Tools and Libraries" || echo "Skipping 'C Development Tools and Libraries' group: not found or error."
}

# Function to install packages on OpenSUSE
install_opensuse() {
    echo "Installing packages for OpenSUSE..."
    for pkg in $BASE_PACKAGES $FCITX5_PACKAGES_SUSE; do
        zypper install -y "$pkg" || echo "Skipping '$pkg': not found or error."
    done
    echo "Installing development tools for OpenSUSE..."
    zypper install -y -t pattern devel_basis || echo "Skipping 'devel_basis' pattern: not found or error."
}


# Detect the distribution by checking for the package manager
if command -v pacman &> /dev/null; then
    install_arch
elif command -v apt-get &> /dev/null; then
    install_ubuntu
elif command -v dnf &> /dev/null; then
    install_fedora
elif command -v zypper &> /dev/null; then
    install_opensuse
else
    echo "Could not detect a supported package manager (pacman, apt, dnf, zypper)."
    exit 1
fi

echo "Basic packages installation complete."
echo "Setting up Fcitx5 environment variables..."

# Create environment file for Fcitx5
mkdir -p /etc/environment.d
cat > /etc/environment.d/90-fcitx5.conf << EOL
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
EOL

echo "Starting Rime configuration..."

# Run the Rime configuration as the user who invoked sudo
if [ -n "$SUDO_USER" ]; then
    sudo -u "$SUDO_USER" bash -c '
        echo "Cloning plum repository..."
        if [ -d "$HOME/plum" ]; then
            echo "$HOME/plum already exists. Skipping clone."
        else
            git clone --depth 1 https://github.com/rime/plum "$HOME/plum"
        fi

        echo "Changing to plum directory..."
        cd "$HOME/plum"

        echo "Installing rime-ice..."
        rime_frontend=fcitx5-rime bash rime-install iDvel/rime-ice:others/recipes/full
    '
else
    echo "Could not determine the user to install Rime for."
    echo "Please run the following commands manually as a regular user:"
    echo "git clone --depth 1 https://github.com/rime/plum ~/plum"
    echo "cd ~/plum"
    echo "rime_frontend=fcitx5-rime bash rime-install iDvel/rime-ice:others/recipes/full"
fi


echo "Installation and setup complete."
echo "Please reboot your system for all changes to take effect."
#+END_SRC
** dotfiles
bash，tmux，Emacs，Nvim，还有其他的配置一直用 GitHub 在同步，迁移起来也很顺畅。

Mac 和 Linux 在文件路径上基本是一致的，需要改的也很少。我也没有啥复杂的开发环境。。。
** 桌面环境和窗口管理
KDE 的 Plasma 太重了，许多功能我也不需要。在 Arch Linux 里，发现 hyprland 自由度很高，就选择了这个。

Gnome 不太喜欢，之前在虚拟机里一直用的 Ubuntu 就是 Gnome，整个的设计和操作逻辑都不太喜欢。看起来和 MacOS 挺像，但是用起来我感觉挺不顺手，而且 Mac 的 Dock 栏我一直不太喜欢。

一直使用的是堆叠式的窗口管理，现在换到了 hyprland 的平铺式，才发现我更喜欢平铺式，特别是在大屏幕上，体验太好了。在 hyprland 里配置快捷键和启动项很方便，在绑定了快捷键之后，可以全键盘操作切换窗口和 Workspace。

登录还是使用的 KDE SDDM。

弄了一个小脚本用来把当前窗口隐藏到 hyprland 的 special Workspace，我感觉很实用：

#+begin_src bash

#!/bin/bash

# Directory to store the original workspace ID of the window
STATE_DIR="/tmp/hypr-special-state"
mkdir -p "$STATE_DIR"

# Get active window info as JSON
active_window_json=$(/usr/bin/hyprctl activewindow -j)

# Extract address and workspace info
window_address=$(echo "$active_window_json" | /usr/bin/jq -r '.address')
workspace_id=$(echo "$active_window_json" | /usr/bin/jq -r '.workspace.id')
workspace_name=$(echo "$active_window_json" | /usr/bin/jq -r '.workspace.name')

# Exit if no active window is found
if [ -z "$window_address" ] || [ "$window_address" == "null" ]; then
    exit 0
fi

# Path to the state file for the current window
STATE_FILE="$STATE_DIR/$window_address"

# Check if the window is in the special workspace
if [[ "$workspace_name" == "special"* ]]; then
    # Window is in a special workspace, move it back to its original workspace
    if [ -f "$STATE_FILE" ]; then
        target_workspace=$(cat "$STATE_FILE")
        rm "$STATE_FILE" # Clean up the state file
    else
        # Fallback: if no state file is found, move to the first available regular workspace
        target_workspace=$(/usr/bin/hyprctl workspaces -j | /usr/bin/jq -r '.[] | select(.id >= 1) | .id' | head -n 1)
        # Default to workspace 1 if no other regular workspace is found
        if [ -z "$target_workspace" ]; then
            target_workspace=1
        fi
    fi

    # Move the specific window to the target workspace
    /usr/bin/hyprctl dispatch movetoworkspace "$target_workspace,address:$window_address"
else
    # Window is not in a special workspace, so move it there and save its current workspace
    echo "$workspace_id" > "$STATE_FILE"
    /usr/bin/hyprctl dispatch movetoworkspacesilent "special,address:$window_address"
fi
#+end_src

** Tips
在国内，安装 Linux 遇到的最大的问题应该就是网络问题了。

在没有安装桌面环境之前，只有命令行，配置代理很不方便。Arch 是可以在安装之前选择国内的镜像的，但是涉及到需要使用 GitHub 和 yay 的包，就不行了。

好在可以直接在 Arch 里， ~sudo pacman -S v2ray~ ，然后把代理的 config.json 用 U 盘挂载，导入进来就好了。
