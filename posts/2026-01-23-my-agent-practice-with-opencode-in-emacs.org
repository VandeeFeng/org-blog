#+title: My Agent Practice with OpenCode in Emacs
#+date: <2026-01-23 11:11>
#+description: ËôΩÁÑ∂Êàë‰∏çÂñúÊ¨¢ vibe codingÔºå‰ΩÜÊòØ SKILL ÊòØÂæàÂÄºÂæóÂ≠¶‰π†ÁöÑ„ÄÇ‰∏Ä‰∏™Â•ΩÁöÑ SKILL ÈáåÂèØ‰ª•Â≠¶Âà∞Â∑•Á®ãÂ∏àÁöÑÁªèÈ™å„ÄÅÈÄªËæëÔºå‰ª•ÂèäÁ≤æÁÇºÁöÑ prompt„ÄÇ
#+filetags: Coding

* TL;DR
ËôΩÁÑ∂Êàë‰∏çÂñúÊ¨¢ vibe codingÔºå‰ΩÜÊòØ SKILL ÊòØÂæàÂÄºÂæóÂ≠¶‰π†ÁöÑ„ÄÇ

‰∏Ä‰∏™Â•ΩÁöÑ SKILL ÈáåÂèØ‰ª•Â≠¶Âà∞Â∑•Á®ãÂ∏àÁöÑÁªèÈ™å„ÄÅÈÄªËæëÔºå‰ª•ÂèäÁ≤æÁÇºÁöÑ prompt„ÄÇ

Tool ÊòØ LLM ÁöÑÂü∫Á°ÄÂ∑•ÂÖ∑Ôºåagent Ê°ÜÊû∂ÊòØÊìç‰ΩúÁ≥ªÁªüÔºåMCP ÊòØ USB Êé•Âè£ÔºåSKILL ÊòØ‰∏ìÂÆ∂ÊäÄËÉΩÊñáÊ°£„ÄÇ
* Agent Skills
** ÁÆÄ‰ªã
[[https://github.com/agentskills/agentskills][agentskills/agentskills]] ÊòØÂâçÊÆµÊó∂Èó¥ [[https://www.linuxfoundation.org/press/linux-foundation-announces-the-formation-of-the-agentic-ai-foundation][Linux Foundation Announces the Formation of the Agentic AI Foundation (AAIF)]] Claude ÂºÄÊ∫êÁöÑ„ÄÇ

Âú®Ëøô‰πãÂâç SKILL Â∞±Â∑≤ÁªèÂá∫Áé∞‰∫Ü„ÄÇ

#+begin_quote
Agent Skills are a simple, open format for giving agents new capabilities and expertise.

Skills are folders of instructions, scripts, and resources that agents can discover and use to perform better at specific tasks. Write once, use everywhere.

via: https://github.com/agentskills/agentskills
#+end_quote

SKILL ÊòØ‰∏Ä‰∏™Êú¨Âú∞Êñá‰ª∂Â§πÔºåÈáåÈù¢ÊòØ SKILL.md„ÄÅscripts„ÄÅreferences„ÄÅtemplatesÔºåÊèê‰æõ agent ‰∏Ä‰∏™‰∏ì‰∏öÈ¢ÜÂüüÁöÑ‰∏ì‰∏öÊäÄËÉΩ„ÄÇ

ËøôÊ†∑ËØ¥ÔºåÂê¨Ëµ∑Êù•ËøòÊòØÊúâÁÇπÊäΩË±°„ÄÇÊàë‰πü‰∏çÊÉ≥Â±ïÂºÄËØ¥Êòé SKILL ÁöÑÊ¶ÇÂøµÔºåËá™Â∑±‰∏äÊâãÊòØÁêÜËß£ÂÆÉÊúÄÂ•ΩÁöÑÊñπÂºè„ÄÇ

[[https://www.vandee.art/blog/2025-11-04-minimal-C-reimplementation-of-claude-skills.html][Áî® C ÊûÅÁÆÄÂ§çÁé∞ Claude Skills]] ÈáåÊòØÊàë‰πãÂâçÁî® C ÂÆûÁé∞ÁöÑÁÆÄÂåñÁâàÁöÑ SKILL ÈÄªËæë„ÄÇ

Ëøô‰∏§‰∏™ÁΩëÁ´ôÈáåÊúâÂæàÂ§ö SKILL ÂèØ‰ª•Êé¢Á¥¢Â≠¶‰π†Ôºöhttps://skillsmp.com/Ôºå https://skills.sh/

** SKILL Ëß£ÂÜ≥‰∫Ü‰ªÄ‰πàÈóÆÈ¢ò
MCP ÁöÑÂ∑•ÂÖ∑‰ø°ÊÅØ‰ºöÂç†Áî®Â§ßÈáèÁöÑ context Á™óÂè£ÔºåSKILL ÂæàÂ•ΩÁöÑÈÅøÂÖç‰∫ÜËøô‰∏™ÈóÆÈ¢ò„ÄÇ

Âú® ~SKILL.md~ YAML ÈÉ®ÂàÜÁöÑ description ÊòØÂØπËøô‰∏™ SKILL ÁöÑ‰ªãÁªç„ÄÇÂΩì agent ËøêË°åÁöÑÊó∂ÂÄôÔºåÂè™‰ºöÈ¢ÑÂä†ËΩΩËøôÈÉ®ÂàÜÂÜÖÂÆπÔºåÂΩì agent Âà§Êñ≠ÈúÄË¶Å‰ΩøÁî®Âà∞ÁöÑÊó∂ÂÄôÔºåÊâç‰ºöÂä†ËΩΩÂÆåÊï¥ÁöÑ ~SKILL.md~ „ÄÇ

Â¶ÇÊûúËØ¥ MCP ÊòØÈÄöÁî®Â∑•ÂÖ∑ÔºåÈÇ£‰πà SKILL Â∞±ÊòØÂèØ‰ª•È´òÂ∫¶Ëá™ÂÆö‰πâÁöÑ local tool„ÄÇ

** ÁºñÂÜô SKILL ÊòØÂú®Âπ≤‰ªÄ‰πà
ÂΩìÈÅáÂà∞‰∏ÄÁßçÁ±ªÂûãÁöÑÈóÆÈ¢òÊó∂ÔºåÊääÂ§ÑÁêÜÂÆÉ‰ª¨ÁöÑÊñπÂºèËßÑËåÉÊÄßÁöÑÂõ∫ÂÆö‰∏ãÊù•ÔºåÂÆÉÂ∞±ÊòØ‰∏Ä‰∏™ SKILL ‰∫Ü„ÄÇ

ËÉΩÂ§üÊääËøô‰∏™ÈóÆÈ¢ò‰ª•ÂèäËß£ÂÜ≥ÈóÆÈ¢òÁöÑÂäûÊ≥ïÂÆåÊï¥ÁöÑÊäΩË±°Êàê‰∏Ä‰∏™ SKILLÔºå‰πüÂèòÁõ∏ÁöÑËØ¥Êòé‰∫ÜËá™Â∑±Â∑≤ÁªèÊéåÊè°‰∫Ü‰∏ÄÁßçÂ§ÑÁêÜÈóÆÈ¢òÁöÑÊñπÊ≥ï„ÄÇ

ÊâÄ‰ª•ÔºåÊàëËôΩÁÑ∂‰∏çÂñúÊ¨¢ vibe codingÔºå‰ΩÜÊòØÂæàÂñúÊ¨¢Áúã SKILL„ÄÇ

‰∏Ä‰∏™Â•ΩÁöÑ SKILL ÈáåÔºåÂèØ‰ª•ÁúãÂà∞‰ºòÁßÄÂ∑•Á®ãÂ∏àÂØπÈóÆÈ¢òÂ§ÑÁêÜ„ÄÅÊäΩË±°ÁöÑËÉΩÂäõ„ÄÇÊõ¥‰∏çÁî®ËØ¥ÈáåÈù¢Ê∂µÁõñ‰∫Ü prompt ÊèêÁ§∫ËØçÂ∑•Á®ãÂèëÂ±ïÂà∞Áé∞Âú®ÁöÑÁªèÈ™åÂíåÊäÄÂ∑ßÔºåËøô‰πàÂ•ΩÁöÑÂ≠¶‰π†ËµÑÊ∫êÔºåÂú®‰ª•ÂæÄÊòØ‰ªòË¥πÈÉΩÂæàÈöæÁúãÂà∞ÁöÑ„ÄÇ

Â§ßÂéÇÊîæÂá∫Êù•ÁöÑÂÆòÊñπ SKILL ÈÇ£ÈÉΩÊòØÈó®Èù¢ÂïäÔºåËøòÊòØÊúâÂæàÂ§öÂπ≤Ë¥ßÁöÑ„ÄÇ

* My Agent Conf
‰∏ãÈù¢ÁöÑÊØè‰∏™Ê†áÈ¢òÂ∞±ÊòØÊàëËßâÂæóÂú®Âíå agent Âêà‰ΩúÁöÑÊó∂ÂÄôÊØîËæÉÂÄºÂæóÂÖ≥Ê≥®ÁöÑÂú∞ÊñπÔºå‰πüÊòØÊàëÁé∞Èò∂ÊÆµÁêÜËß£Âà∞ÁöÑ‰∏Ä‰∫õÂÆûË∑µÂéüÂàô„ÄÇ

‰ªé Claude Code ËΩ¨Âà∞ OpenCodeÔºåÊÑüËßâ‰∏ÄÂàáËâØÂ•Ω„ÄÇ

Êàë‰∏çÊòØÁ®ãÂ∫èÂëòÔºå‰πü‰∏çÈúÄË¶ÅÈ´òË¥®ÈáèÁöÑ‰ª£Á†Å„ÄÇÊàëÊõ¥ÂñúÊ¨¢ OpenCode ÁöÑ‰∏Ä‰∫õËÆæËÆ°ÁêÜÂøµÔºåClaude Code ÈôêÂà∂Â§™Â§öÔºå‰πüÂÖ¨ÂºÄË°®Á§∫‰∏çËÆ©Êàë‰ª¨Áî®ÔºåÈÇ£Â∞±‰∏çÁî®Â•Ω‰∫Ü„ÄÇ

Âú® OpenCode Èáå vibe ‰∏Ä‰∫õÂ∞èÁé©ÊÑèËøòÊòØÂæàÂ§üÁî®ÁöÑ„ÄÇ

ÊàëËôΩÁÑ∂‰∏çÂñúÊ¨¢ vibeÔºå‰ΩÜÊòØÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∫õÂéüÂûãÂÅáËÆæÁöÑÊó∂ÂÄôÔºåvibe ËøòÊòØÊûÅÂ•ΩÁöÑ„ÄÇ

ÂÜç‰∏Ä‰∏™Ôºå‰∏ç‰∫ÜËß£ vibe ÂèàÊÄé‰πàËÉΩËØ¥Ëá™Â∑±‰∏çÂñúÊ¨¢Âë¢Ôºü

** Core Rules
Just files and loops!

Provide specific ~Best Practices~, ~Pros & Cons~, ~Red Flags~

Keep it simple!

** Maintain a hierarchical codebase map

#+begin_quote
Your best engineers don‚Äôt grep randomly. They have a mental map:
- What each folder owns
- What breaks if you touch it wrong
- Where the real logic lives

via: https://www.railly.dev/blog/intent-layer/
#+end_quote

SKILL: intent-layer https://github.com/crafter-station/skills

Â¶ÇÊûúÊØèÊ¨°Êñ∞ÁöÑ session ÈÉΩËÆ© agent Êé¢Á¥¢‰∏ÄÊ¨°È°πÁõÆ‰ª£Á†ÅÔºåÂèà‰∏çÊñπ‰æøÔºåÂèàÊµ™Ë¥πÊó∂Èó¥„ÄÇ

ÁªôÈ°πÁõÆ‰ª£Á†ÅÊèê‰æõ‰∏Ä‰∏™ÊåÅÁª≠Êõ¥Êñ∞ÁöÑ codebase map ËøòÊòØÂæàÂøÖË¶ÅÁöÑ„ÄÇ

ËøôËÆ© agent Âú®ÊØèÊ¨°ÂØπËØùÁöÑÊó∂ÂÄôÂú® context ÈáåÂåÖÂê´È°πÁõÆÁöÑÂü∫Êú¨‰ø°ÊÅØÂíåÊû∂ÊûÑ„ÄÇ

also: https://github.com/affaan-m/everything-claude-code/blob/main/commands/update-codemaps.md

** Prepared with clear purpose
SKILL: Onboard https://github.com/ChrisWiles/claude-code-showcase/blob/main/.claude/commands/onboard.md

Âú®ÂºÄÂßãÂÖ∑‰ΩìÁöÑ‰ªªÂä°‰πãÂâçÔºåÁªô‰∫à agent ÊòéÁ°ÆÁöÑÁõÆÊ†á‰ª•ÂèäË¶ÅÊ∂âÂèäÂà∞ÁöÑÂÖ∑‰ΩìÊñá‰ª∂„ÄÇ

ÊòéÁ°ÆÊ∏ÖÊô∞ÁöÑÊèèËø∞Ëá™Â∑±ÁöÑÈúÄÊ±ÇÈùûÂ∏∏ÈáçË¶Å„ÄÇDO and DONOT.

ÂØπ‰∫éÂ§ßÈÉ®ÂàÜÊ®°ÂûãÔºåËã±Êñá prompt ÊïàÊûúÊØî‰∏≠ÊñáÂ•Ω„ÄÇ

** Just files and loops, no more complicated
SKILL: Planning with Files https://github.com/OthmanAdi/planning-with-files

Âú® agent ÊâßË°åÂÖ∑‰Ωì‰ªªÂä°ÁöÑÊó∂ÂÄôÔºåplanning with files Ëøô‰∏™Ê°ÜÊû∂ÁöÑËÆæËÆ°ÂæàÂÄºÂæóÂ≠¶‰π†„ÄÇ

ÂÆÉÁî®‰∏â‰∏™Êñá‰ª∂ËÆ∞ÂΩïÂíåËßÑÂàí agent ÁöÑ task planÔºåÈùûÂ∏∏ÁÆÄÊ¥ÅÔºåÊïàÊûúÊãîÁæ§„ÄÇ

ÁªìÂêàÊàëÂú® opencode ÈáåÁöÑ‰ΩøÁî®ÔºåÊàëÂä†‰∏ä‰∫Ü memory ÈÉ®ÂàÜÔºö

#+begin_src
1. Use the `session-info` tool to retrieve the current conversation's [session-title]
2. Run `date +%Y%m%d-%H%M%S` command to get the [YYYYMMDD-HHMMSS timestamp]
   Create the `session folder`: `mkdir -p $HOME/.MemoryMD/$(basename $(git rev-parse --show-toplevel))/[YYYYMMDD-HHMMSS timestamp]-[session-title]`
3. All generated markdown files should be created in that `session folder`.
#+end_src

Ê≤°ÊúâÈÄâÊã©Âú®È°πÁõÆÊ†πÁõÆÂΩï‰∏ãÂàõÂª∫ÊòØ‰∏∫‰∫ÜÂ§ö‰∏™ session Âíå git-worktree Âπ∂Ë°åÂú∫ÊôØ‰∏ãÔºåÊñπ‰æøÂÖ±‰∫´„ÄÇ

session-info ÊòØ‰∏Ä‰∏™ÂæàÁÆÄÂçïÁöÑ toolÔºåÂú® OpenCode ÈáåÁî®Êù•Ëé∑ÂèñÂΩìÂâç session ‰ø°ÊÅØÔºåÁîüÊàê‰∏äÈù¢ÊèêÂà∞ÁöÑÊñá‰ª∂Â§πÔºö

~tools/session-info.ts~ :

#+begin_src js
import { tool } from "@opencode-ai/plugin"
import { execSync } from "child_process"
import { homedir } from "os"

export default tool({
  description: "Get current session information including title",
  args: {},
  async execute(args, context) {
    const { sessionID, agent } = context

    const sessionDir = `${homedir()}/.local/share/opencode/storage/session`

    try {
      const result = execSync(`find ${sessionDir} -name "${sessionID}.json" 2>/dev/null | head -1`, { encoding: "utf-8" })

      if (!result.trim()) {
        throw new Error("Session file not found")
      }

      const sessionFile = result.trim()
      const sessionData = JSON.parse(require("fs").readFileSync(sessionFile, "utf-8"))

      return JSON.stringify({
        sessionID,
        agent,
        title: sessionData.title || null,
        directory: sessionData.directory || null,
        time: sessionData.time || null,
      }, null, 2)
    } catch (error) {
      return JSON.stringify({ error: error.message, sessionID, agent }, null, 2)
    }
  },
})
#+end_src

** Handoff when stucked
SKILL: handoff https://github.com/mitsuhiko/agent-stuff/blob/main/commands/handoff.md

ÊúâÊó∂ÂÄô agent ‰ºöÂç°‰ΩèÔºåÈô∑ÂÖ•Ê≠ªÂæ™ÁéØÔºåÊûúÊñ≠ handoff ÈáçÂºÄÔºå‰∏çÁî®Êµ™Ë¥πÊó∂Èó¥„ÄÇ

** Maintain memory
ÊàëÊää planning-with-files ÁöÑÊñáÊ°£Âíå Handoff ÁöÑÊñáÊ°£ÂΩì‰ΩúÈ°πÁõÆÁöÑ memoryÔºåËÆæËÆ°‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑ SKILL Êù•Ê†πÊçÆÂÖ≥ÈîÆÂ≠óÊêúÁ¥¢Ôºö

Áé∞Âú®ÊúâËÆ∏Â§öÈíàÂØπ agent ÁöÑ memory È°πÁõÆÔºå‰ΩÜÊòØÊàëÊÑüËßâËøô‰∏™Ê¶ÇÂøµÊú¨Ë∫´‰πüÊâçÂàöÂá∫Êù•Ôºå‰ªäÂπ¥Â∫îËØ•ÊúâÊõ¥ÊàêÁÜüÁöÑÂÆûÁé∞„ÄÇ

ÊöÇÊó∂Â∞±Áî®Ëøô‰∏™ÁÆÄÂçïÊñπÊ°àËøáÊ∏°‰∏Ä‰∏ã„ÄÇ

#+begin_src
---
name: memory-md
description: Memory management system for storing and retrieving conversation history and context.When user ask anything about project's memory, automatically use this skill.
---

Memory management system for storing and retrieving conversation history and context.


## Parse guide

Parse [quest] as follows:

1. **List command**: If [quest] starts with `-l` or `--list`
   - List recent memory files

2. **Search command**: If [quest] starts with `-s` or `--search`
   - All remaining arguments are search keywords (comma-separated or space-separated)
   - Example: `-s apple,banana` or `-s apple banana` ‚Üí keywords: ["apple", "banana"]

3. **Default search**: If no flags provided, treat entire [quest] as search keywords
   - Example: `authentication jwt` ‚Üí keywords: ["authentication", "jwt"]

4. **No results**: If no keywords provided in [quest] after parsing
   - Ask user: "What keywords are you searching for?"

## Memory File Location

Memory files are stored in `$HOME/.MemoryMD/` with the following structure:

```
$HOME/.MemoryMD/
‚îú‚îÄ‚îÄ [project-name]/                     # Project folders
‚îÇ   ‚îú‚îÄ‚îÄ YYYYMMDD-HHMMSS-[session-title]/  # Session folders
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_plan.md                # Task planning document
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ findings.md                 # Research findings
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ progress.md                 # Progress tracking
‚îî‚îÄ‚îÄ handoffs/                           # Handoff summaries
    ‚îî‚îÄ‚îÄ YYYYMMDD-HHMMSS-[slug].md      # Session handoff files
```

Examples:
- `agent-conf/20250120-143025-implement-auth/` - Session folder
- `handoffs/20250120-143025-fix-issue-42.md` - Handoff file

## Commands

### --list or -l

List the 20 most recent memory folders/files, sorted by timestamp (newest first).

**Bash command:**
```bash
memory_dir="$HOME/.MemoryMD"

# List session folders grouped by project (sorted newest first)
find "$memory_dir" -maxdepth 2 -type d -name "????????-??????-*" | sort -r | head -20 | awk -F/ '{
    project = $(NF-1)
    foldername = $NF
    timestamp = substr(foldername, 1, 15)
    title = substr(foldername, 17)
    if (project != prev_project) {
        if (prev_project != "") print ""
        print "**" project "**"
        prev_project = project
    }
    print "  [" timestamp "] " title
}'

# List handoff files (sorted newest first)
echo ""
echo "Recent handoffs:"
find "$memory_dir/handoffs" -maxdepth 1 -type f -name "*.md" | sort -r | head -20 | while read file; do
    filename=$(basename "$file")
    title=${filename#*-}
    title=${title%.md}
    echo "$title - $filename"
done
```

**Output format:**
```
**agent-conf:**
  [20250120-143025] implement-auth
  [20250119-091530] fix-issue-42

**another-project:**
  [20250118-1530] api-handler

Recent handoffs:
  fix-issue-42 - 20250120-143025-fix-issue-42.md
  implement-auth - 20250119-091530-implement-auth.md
```

### --search or -s

Search memory files for keywords in both Chinese and English.

Use your Glob and Grep tools first.

First perform exact keyword search. If no results found, search for related similar keywords.

If still no results after all searches, ask user: "What keywords are you searching for?"

**Output Examples:**

```md
Search query: [keywords]

## Found in: agent-conf/20250120-143025-implement-auth/task_plan.md
[summary of your findings]

## Found in: agent-conf/20250120-143025-implement-auth/findings.md
[summary of your findings]
```

Bash commands below serve as auxiliary reference:

**Bash command:**
```bash
memory_dir="$HOME/.MemoryMD"

# Search for keywords in all markdown files
rg -i -t md "$keywords" "$memory_dir" --follow

# Alternative: Search with context (2 lines before and after matches)
rg -i -C 2 -t md "$keywords" "$memory_dir" --follow
```

**Options:**
- `-i`: Case-insensitive search
- `-C N`: Show N lines of context before and after matches
- `-t md`: Search only markdown files
- `--follow`: Follow symbolic links
#+end_src

** Maintain useful patterns
SKILL: https://github.com/affaan-m/everything-claude-code/blob/main/commands/learn.md

Âú®Ëß£ÂÜ≥ÂÆûÈôÖÁöÑ‰ª£Á†ÅÈóÆÈ¢òÁöÑÊó∂ÂÄôÔºåÊúâËÆ∏Â§öÊñπÊ°àÊòØÂèØ‰ª•Âõ∫ÂÆö‰∏ãÊù•Â§çÁî®ÁöÑ„ÄÇ

Ê†πÊçÆËøô‰∏™ SKILLÔºåÊàëËÆæËÆ°‰∫Ü‰∏Ä‰∏™ learned skill„ÄÇËøô‰∏™ SKILL ÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™Á¥¢ÂºïÔºåÂú® description ÈÉ®ÂàÜÂä†‰∏ä learned ÁöÑÊèèËø∞‰ø°ÊÅØ„ÄÇ

learn skill ‰ºöÊ†πÊçÆÂΩìÂâç‰ºöËØùÁöÑ session Âõ∫ÂÆö‰∏ãÊù•Êúâ‰ª∑ÂÄºÁöÑ patternÔºåÁîüÊàê skillÔºåËá™Âä®Ê∑ªÂä†Âà∞ learned skill ÁöÑ description ÈÉ®ÂàÜÔºåËøôÊ†∑ agent Âú®Âä†ËΩΩÁöÑÊó∂ÂÄôÂ∞±ÂèØ‰ª•Áü•ÈÅìÊúâÂì™‰∫õ learned skill ‰∫Ü„ÄÇ

‰∏çÈÄâÊã©Êää learned skill ÁîüÊàêÂçïÁã¨ÁöÑ skill Êñá‰ª∂Â§πÊòØÂõ†‰∏∫ÂÆÉ‰ª¨ÁöÑÊôÆÈÅçÊÄß‰∏çÂº∫Ôºå‰πüÁªèÂ∏∏Ë¶ÅÊõ¥Êñ∞Âíå‰øÆÊîπÔºå‰∏çËÉΩÂÆåÂÖ®ÂΩì‰Ωú SKILL Êù•ËÆæËÆ°„ÄÇ

Learn skillÔºö

#+begin_src
---
name: learn
description: >
  Extract reusable patterns from sessions and create dynamic skills. Use when you need to save learned patterns, error resolutions, debugging techniques, or project-specific knowledge to ~/.config/opencode/skill/learned/.
  Trigger, User asks to extract learning, save patterns, or run /learn command.
  All learned skills in `~/.config/opencode/skill/learned/` are automatically discoverable
  `~/.config/opencode/skill/learned/SKILL.md` is the index off all learned skills
---

# Learn Skill

Dynamically extract and store reusable patterns as skills.

## Quick Start

When user wants to extract learning from current session:

1. Review session context for extractable patterns
2. Identify the most valuable/reusable insight,list them
3. Ask user for confirmation before creating skill file
4. Create `~/.config/opencode/skill/learned/[skill-name].md` - Use [templates/learned-skill-template.md](templates/learned-skill-template.md) as reference
5. Update `~/.config/opencode/skill/learned/SKILL.md` to include the new skill - Use  [templates/SKILL.md](templates/SKILL.md) as reference
6. Run `ls -1 ~/.config/opencode/skill/learned/*.md 2>/dev/null | grep -v SKILL.md | wc -l`, update the total skills number.

## What to Extract

### 1. Error Resolution Patterns
- What error occurred?
- What was the root cause?
- What fixed it?
- Is this reusable for similar errors?

### 2. Debugging Techniques
- Non-obvious debugging steps
- Tool combinations that worked
- Diagnostic patterns

### 3. Workarounds
- Library quirks
- API limitations
- Version-specific fixes

### 4. Project-Specific Patterns
- Codebase conventions discovered
- Architecture decisions made
- Integration patterns

## Quality Guidelines

### DO Extract:
- Error patterns that occur more than once
- Non-obvious debugging techniques
- Workarounds for library quirks
- Architecture decisions and their rationale
- Integration patterns across services/tools

### DO NOT Extract:
- Trivial fixes (typos, simple syntax errors)
- One-time issues (specific API outages, temporary glitches)
- Obvious solutions (standard library usage without special context)
- Information already well-documented elsewhere

### Tips for Quality Skills
1. **Be Specific**: Narrow trigger conditions = better matching
2. **Include Examples**: Code snippets make patterns actionable
3. **Document Why**: Explain the problem, not just the solution
4. **Keep Focused**: One pattern per skill
5. **Use Descriptive Names**: Names should indicate what the skill solves


## Skill File Format

### Individual Skill Files

Use the template file [templates/learned-skill-template.md](templates/learned-skill-template.md) as the base for all learned skills.

Key sections:
- **Frontmatter**: name and description (critical for skill discovery)
- **Problem**: What specific issue this solves
- **Solution**: Actionable steps to implement
- **Example**: Code snippet if applicable
- **When to Use**: Trigger conditions for activation
- **Related Patterns**: Cross-references to other skills

### SKILL.md

Use the template file [templates/SKILL.md](templates/SKILL.md) as the base for maintaining the learned skills index.

Purpose:
- Provides a categorized listing of all learned skills
- Enables easy browsing and discovery of patterns
- Tracks skill count and update timestamp

Update SKILL.md whenever saving a new skill.

## Extraction Process

### Step 1: Review Session Context

Use `session-info` tool to get session details if needed.

Use `memory-md` skill to find relevant memories.

Look for:
- Repeated error fixes
- Non-obvious solutions
- Workarounds discovered
- Best practices learned

### Step 2: Identify Pattern

Ask yourself:
- Is this reusable? (Will save time in future sessions)
- Is this non-trivial? (Not typos or simple syntax errors)
- Is this generalizable? (Not one-time issues)

Prioritize patterns that:
- Solve common problems
- Apply across multiple projects
- Document non-obvious solutions

### Step 3: Draft Skill

Use the skill file format above.

**Naming Convention:**
- Use kebab-case for skill names
- Make names descriptive but concise
- Example: `async-error-handling-pattern`, `docker-volume-permission-fix`

**Frontmatter:**
```yaml
---
name: [skill-name]
description: Use when [trigger conditions]. Covers [specific problem/solution].
---
```

The description is critical - it's what helps the skill system know when to load this skill.

### Step 4: Validate

Before presenting to user:
- Check that the skill has clear trigger conditions
- Ensure the solution is actionable
- Verify code examples are correct
- Confirm the pattern is truly reusable

### Step 5: Present and Save

Show the user:
1. Pattern name
2. Brief description of what was extracted
3. Why it's valuable

Ask: "Save this pattern to learned skills? (y/n)"

If yes, save to `~/.config/opencode/skill/learned/[skill-name].md`

### Step 6: Update `learned/SKILL.md`

1. Update the description of the new learned skill.Append this part: [name of learned skill 1] - [description of learned skill 1]

example YAML of `learned/SKILL.md`:

```md
---
name: learned
description: >
  learned skill is a collection of learned skill user create.It's a index of all learned skills.
  We have these learned skill below:
  [name of learned skill 1] - [description of learned skill 1]
  [name of learned skill 1] - [description of learned skill 2]
---
```

2. Update the new skill to the index section.

## Common Use Cases

### User runs /learn command
```
User: /learn
```
1. Review session for extractable patterns
2. Present candidate patterns to user
3. Ask which to save
4. Save selected patterns

### User asks to extract specific topic
```
User: Extract what we learned about async error handling
```
1. Search session context for async/error patterns
2. Compile findings
3. Generate skill file
4. Present and save

### User wants to capture architecture decision
```
User: Save the event sourcing pattern we used
```
1. Extract the pattern details
2. Document rationale and trade-offs
3. Create skill with example code
4. Present and save

## Integration with Other Skills

This skill works well with:
- **memory-md**: For accessing related patterns from past sessions
- **skill-creator**: For creating more complex, bundled skills
#+end_src

Learnd skillÔºö

#+begin_src
---
name: learned
description: >
  learned skill is a collection of learned skill user create.It's a index of all learned skills.
  We have these learned skill below:
  [name of learned skill 1] - [description of learned skill 1]
  [name of learned skill 1] - [description of learned skill 2]
---

# Learned Skills Index

You can read the skill file to load the skill you need.

Treat these skill file below as `learned skill`'s references.

## Error Patterns
- [skill-1.md](skill-1.md)
- [skill-2.md](skill-2.md)

## Debugging Techniques
- [skill-3.md](skill-3.md)

## Workarounds
- [skill-4.md](skill-4.md)

## Project-Specific
- [skill-5.md](skill-5.md)

# Statistics
Total skills: [count]
Last updated: [date]
#+end_src

** Maintain code quality and style
SKILL: code-simplifier: https://github.com/anthropics/claude-plugins-official/blob/main/plugins/code-simplifier/agents/code-simplifier.md

LLM Âú®ÁºñÂÜô‰ª£Á†ÅÁöÑÊó∂ÂÄôÔºåÁâπÂà´ÊòØÂ§ßÈáè‰ª£Á†ÅÔºåÂ§çÊùÇ‰ª£Á†ÅÁöÑÊó∂ÂÄôÔºåÂæàÂÆπÊòìÁäØÁóÖÔºåÁºñÂÜôÈáçÂ§çÊÄßÁöÑ‰ª£Á†ÅÔºåËøôÊòØÂõ†‰∏∫‰∏ä‰∏ãÊñáÂ§ö‰∫ÜÔºåÂáÜÁ°ÆÊÄß‰∏ãÈôç„ÄÇ

Âú®ÊØèÊ¨° agent ÂÜôÂÆå‰ª£Á†Å‰πãÂêéËøõË°å‰ª£Á†ÅÂÆ°Êü•Âíå‰ª£Á†Å‰ºòÂåñ„ÄÇ

Âú® prompt ‰∏äÔºå‰∫≤ÊµãÂä†‰∏äÔºöËøôÊòØÂà´‰∫∫ÁöÑ‰ª£Á†ÅÔºåÊïàÊûú‰ºöÊõ¥Â•Ωü§£„ÄÇLLM ÊãçÈ©¨Â±ÅÁöÑÊ¶ÇÁéáÂ§ßÂπÖ‰∏ãÈôç„ÄÇ

* OpenCode in Emacs
Âú® Emacs ÈáåÁé∞Âú®Âíå OpenCode ‰∫§‰∫íÊúÄÊñπ‰æøÁöÑÂ∞±ÊòØ [[https://github.com/xenodium/agent-shell][agent-shell]] ‰∫Ü„ÄÇ

Âú®ÁªàÁ´ØÈáåÁî® OpenCode ÊúÄ‰∏çÊñπ‰æøÁöÑÂ∞±ÊòØ‰∏çËÉΩÁõ¥Êé•ÈÄâÊã©ÊñáÊú¨Ôºåagent-shell Ëß£ÂÜ≥‰∫ÜËøô‰∏™ÈóÆÈ¢ò:

~agent-shell-send-dwim~ „ÄÅ ~agent-shell-send-file~ „ÄÅ ~agent-shell-send-region~ „ÄÅ ~agent-shell-insert-file~ ËøôÂá†‰∏™ÂéüÁîüÁöÑÊåá‰ª§ÈÖçÁΩÆÂ•ΩÂø´Êç∑ÈîÆÂ∞± OK ‰∫Ü„ÄÇ

slash command ÈÄöËøá Emacs ÁöÑËá™Âä®Ë°•ÂÖ®ÔºåÂü∫Êú¨ÊòØÊó†ÊÑüÂàáÊç¢„ÄÇ

‰∏çË∂≥ÁöÑÂú∞ÊñπÂ∞±ÊòØÔºåagent-shell ‰∏ç‰ºöÂàóÂá∫ OpenCode ÁöÑ subagent„ÄÇÊâÄ‰ª•ÊàëÂä†‰∫Ü‰∏Ä‰∫õË°•‰∏ÅÊù•ÊòæÁ§∫ subagent„ÄÇ

Áî±‰∫é @ Âú® agent-shell ÈáåÈªòËÆ§Áî®Êù• @fileÔºåÊâÄ‰ª•Áî® @@ Êù• @ subagentÔºåÂπ∂ÊîØÊåÅ‰∫ÜËá™Âä®Ë°•ÂÖ®„ÄÇVim ÁöÑ normal Ê®°Âºè‰∏ãÊåâ @ ‰ºöÈÄâÊã© primary agent„ÄÇ

ÂÖ∑‰Ωì‰ª£Á†ÅÔºö

#+begin_src elisp
(use-package agent-shell
  :after evil
  :config
  (setq agent-shell-opencode-authentication
        (agent-shell-opencode-make-authentication :none t))
  ;; disable creating transcript file
  (setq agent-shell-transcript-file-path-function nil)

  ;; Evil state-specific RET behavior: insert mode = newline, normal mode = send
  (evil-define-key 'insert agent-shell-mode-map (kbd "RET") #'newline)
  (evil-define-key 'normal agent-shell-mode-map (kbd "RET") #'comint-send-input)
  (evil-define-key 'normal agent-shell-mode-map (kbd "@") #'agent-shell-set-session-mode)

  ;; Configure *agent-shell-diff* buffers to start in Emacs state
  (add-hook 'diff-mode-hook
            (lambda ()
              (when (string-match-p "\\*agent-shell-diff\\*" (buffer-name))
                (evil-emacs-state)))))

;;; agent-shell OpenCode Subagent Support
;;; Shows available subagents and enables @@subagent invocation syntax
(defvar agent-shell-opencode--subagents nil
  "Cached list of available subagents.")

(defun agent-shell-opencode--get-subagent-description (agent-name)
  "Get description for subagent AGENT-NAME from its config file."
  (let* ((config-file (expand-file-name (format "%s.md" agent-name)
                                        "~/.config/opencode/agents/"))
         (description
          (when (file-exists-p config-file)
            (with-temp-buffer
              (insert-file-contents config-file)
              (goto-char (point-min))
              (when (re-search-forward "^description: \\(.*\\)$" nil t)
                (match-string 1))))))
    (or description "Subagent")))

(defun agent-shell-opencode--list-subagents ()
  "List all subagents using opencode agent list command.
Returns list of agent alists with :id, :name, :description."
  (let* ((output (shell-command-to-string "opencode agent list"))
         (lines (split-string output "\n"))
         agents)
    (dolist (line lines)
      (when (string-match "^\\([^\s]+\\) (subagent)$" line)
        (let* ((name (match-string 1 line))
               (description (agent-shell-opencode--get-subagent-description name)))
          (push `((:id . ,name)
                  (:name . ,name)
                  (:description . ,description))
                agents))))
    (nreverse agents)))

(defun agent-shell-opencode--format-subagents (subagents)
  "Format SUBAGENTS list for display."
  (mapconcat
   (lambda (agent)
     (let ((name (map-elt agent :name))
           (desc (map-elt agent :description)))
       (format "@@%s - %s" (propertize name 'font-lock-face 'font-lock-keyword-face) desc)))
   subagents
   "\n"))

(defun agent-shell-opencode--show-subagents-fragment ()
  "Add subagents UI fragment after available modes fragment."
  (when-let ((subagents agent-shell-opencode--subagents)
             ((> (length subagents) 0))
             ((fboundp 'agent-shell--update-fragment))
             (state agent-shell--state)
             (request-count (map-elt state :request-count))
             (buffer (map-elt state :buffer)))
    (with-current-buffer buffer
      (save-excursion
        (goto-char (point-max))
        (when (text-property-search-backward
               'agent-shell-ui-state nil
               (lambda (_ prop-state)
                 (equal (map-elt prop-state :qualified-id)
                        (format "%s-available_modes" request-count)))
               t)
          (let* ((block-range (agent-shell-ui--block-range :position (point)))
                 (insert-pos (map-elt block-range :end)))
            (goto-char insert-pos)
            (let ((inhibit-read-only t))
              (insert "\n\n")
              (agent-shell-ui--insert-fragment
               (agent-shell-ui-make-fragment-model
                :namespace-id (number-to-string request-count)
                :block-id "available_subagents"
                :label-left (propertize "Available subagents" 'font-lock-face 'font-lock-doc-markup-face)
                :body (agent-shell-opencode--format-subagents subagents))
               (format "%s-available_subagents" request-count)))))))))

(defun agent-shell-opencode--load-subagents-delayed ()
  "Load subagents and show them in UI after delay."
  (run-with-timer
   0.5 nil
   (lambda ()
     (when-let ((subagents (agent-shell-opencode--list-subagents))
                ((> (length subagents) 0)))
       (setq agent-shell-opencode--subagents subagents)
       (agent-shell-opencode--show-subagents-fragment)))))

(defun agent-shell-opencode--around-initiate-session (orig-fun &rest args)
  "Around advice for agent-shell--initiate-session."
  (let* ((plist args)
         (on-session-init (plist-get plist :on-session-init))
         (new-on-session-init
          (lambda ()
            (funcall on-session-init)
            (agent-shell-opencode--load-subagents-delayed))))
    (plist-put plist :on-session-init new-on-session-init)
    (apply orig-fun plist)))

(advice-add 'agent-shell--initiate-session :around
            #'agent-shell-opencode--around-initiate-session)

;;; Transform @@subagent syntax to @subagent before sending to OpenCode
(defun agent-shell-opencode--filter-send-command-args (args)
  "Transform @@subagent to @subagent in prompt before sending."
  (let ((prompt (plist-get args :prompt)))
    (when (and prompt (stringp prompt))
      (plist-put args :prompt (replace-regexp-in-string "@@" "@" prompt))))
  args)

(advice-add 'agent-shell--send-command :filter-args
            #'agent-shell-opencode--filter-send-command-args)

;;; @@subagent completion support
(defun agent-shell-opencode--subagent-completion-at-point ()
  "Complete subagent names after @@ prefix."
  (when-let* ((bounds (agent-shell--completion-bounds "[:alnum:]_-" ?@))
              ((save-excursion
                 (goto-char (map-elt bounds :start))
                 (eq (char-before) ?@)))
              (subagents agent-shell-opencode--subagents)
              (descriptions (mapcar (lambda (a)
                                      (cons (map-elt a :name)
                                            (map-elt a :description)))
                                    subagents)))
    (list (map-elt bounds :start) (map-elt bounds :end)
          (mapcar #'car descriptions)
          :exclusive t
          :annotation-function
          (lambda (name)
            (when-let* ((desc (map-elt descriptions name)))
              (concat "  " desc)))
          :company-kind (lambda (_) 'function))))

(defun agent-shell-opencode--setup-completion ()
  "Set up @@subagent completion in agent-shell."
  (add-hook 'completion-at-point-functions
            #'agent-shell-opencode--subagent-completion-at-point
            nil t))

(add-hook 'agent-shell-mode-hook #'agent-shell-opencode--setup-completion)
#+end_src

* Bubblewrap Sandbox
Claude ÂÆòÊñπÂú® Linux Èáå‰πüÊòØ‰ΩøÁî®ÁöÑ bubblewrap ‰Ωú‰∏∫ sandboxÔºåÂπ∂ÂÅö‰∫ÜËÆ∏Â§öÈíàÂØπÊÄßÁöÑ‰ºòÂåñ„ÄÇ

ËÆ© LLM ÁîüÊàê‰∫Ü‰∏Ä‰∏™ bash ËÑöÊú¨Âú® bubblewrap sandbox ÈáåËøêË°å OpenCodeÔºö

#+begin_src shell
#!/bin/bash
# opencode bubblewrap sandbox script
# https://patrickmccanna.net/a-better-way-to-limit-claude-code-and-other-coding-agents-access-to-secrets/
# https://www.luiscardoso.dev/blog/sandboxes-for-ai

set -euo pipefail

# Configuration
PROJECT_DIR="$(pwd)"
OPENCODE_BIN="$HOME/.npm-global/bin/opencode"
OPENCODE_CONFIG="$HOME/.config/opencode"
NPM_BIN="$HOME/.npm-global"

# Validate paths
if [ ! -x "$OPENCODE_BIN" ]; then
  echo "Error: opencode binary not found or not executable: $OPENCODE_BIN"
  exit 1
fi

# Check if we need to allow network access (default: yes for opencode's MCP servers)
SHARE_NET="--share-net"

# Run opencode in bubblewrap sandbox
bwrap \
  --ro-bind /usr /usr \
  --ro-bind /lib /lib \
  --ro-bind /bin /bin \
  --ro-bind /etc/resolv.conf /etc/resolv.conf \
  --ro-bind /etc/hosts /etc/hosts \
  --ro-bind /etc/ssl /etc/ssl \
  --ro-bind /etc/passwd /etc/passwd \
  --ro-bind /etc/group /etc/group \
  --ro-bind "$NPM_BIN" "$NPM_BIN" \
  $(for env_file in "$PROJECT_DIR"/.env*; do [ -e "$env_file" ] && echo "--ro-bind /dev/null \"$env_file\""; done) \
  --ro-bind /dev/null "$HOME/.aws" \
  --ro-bind /dev/null "$HOME/.ssh" \
  --ro-bind /dev/null "$HOME/.gnupg" \
  --ro-bind /dev/null "$HOME/.config/gcloud" \
  --bind "$OPENCODE_CONFIG" "$OPENCODE_CONFIG" \
  --bind "$PROJECT_DIR" "$PROJECT_DIR" \
  --bind "$HOME/.npm-global/" "$HOME/.npm-global/" \
  --bind "$HOME/.local/share/opencode" "$HOME/.local/share/opencode" \
  --bind "$HOME/.MemoryMD/" "$HOME/.MemoryMD/" \
  --bind "$HOME/.cache/opencode/" "$HOME/.cache/opencode/" \
  --tmpfs /tmp \
  --proc /proc \
  --dev /dev \
  $SHARE_NET \
  --unshare-pid \
  --unshare-ipc \
  --unshare-uts \
  --die-with-parent \
  --new-session \
  --chdir "$PROJECT_DIR" \
  --setenv HOME "$HOME" \
  --setenv USER "$(whoami)" \
  "$OPENCODE_BIN" "$@"
#+end_src
