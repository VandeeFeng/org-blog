<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://www.vandee.art/blog/rss.xml"
      title="RSS feed for https://www.vandee.art/blog/">
<title>PKM（个人知识管理）构建手册 - Nvim</title>
<meta property="og:title" content="PKM（个人知识管理）构建手册 - Nvim">
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.vandee.art/blog/2024-08-02-nvim-pkm-manual.html">
<meta name="author" content="Vandee">
       <meta name="referrer" content="origin-when-cross-origin">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">

       <link rel="stylesheet" href="assets/css/blog-style.css" type="text/css"/>
       <link rel="stylesheet"
             href="https://testingcf.jsdelivr.net/npm/remixicon@4.7.0/fonts/remixicon.css"/>
       <link rel="stylesheet"
             href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui@4.0.12/dist/fancybox.css"/>
       <link rel="icon" type="image/x-icon" href="/favicon.ico"/>

       <script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui@4.0.12/dist/fancybox.umd.js" defer></script>
       <script src="https://testingcf.jsdelivr.net/npm/pangu@7.2.0/dist/browser/pangu.umd.min.js" defer></script>
       <script defer>
         document.addEventListener("DOMContentLoaded", function () {
           pangu.autoSpacingPage();
         });
       </script>

       <script src="assets/js/app.js" defer></script>
       <script src="assets/js/copyCode.js" defer></script>
       <script src="assets/js/shiba.js" defer></script>
       <script src="assets/js/search.js" defer></script></head>
<body>
<div id="preamble" class="status">
      <header>
      <h1><a href="https://www.vandee.art/blog/">Vandee's Blog</a></h1>
      <img class="shiba" width="100px" src="assets/shiba_gif/shiba_idle_8fps.gif">
      <nav>
      <a href="https://www.vandee.art/blog/">Home</a>
      <a href="https://x404.xyz/wiki">Wiki</a>
      <a href="https://x404.xyz/photo">Photo</a>
      <a href="archive.html">Archive</a>
      <a href="tags.html">Tags</a>
      <div id="search-container">
        <input type="text" id="search-input" placeholder="e.g. Emacs PKM...">
        <i class="ri-search-line ri-xl"></i>
      </div>
      </nav>
      </header></div>
<div id="content">
<div class="post-date">02 Aug 2024</div><h1 class="post-title"><a href="https://www.vandee.art/blog/2024-08-02-nvim-pkm-manual.html">PKM（个人知识管理）构建手册 - Nvim</a></h1>
<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4ec2526">Intro</a></li>
<li><a href="#orge1a15b1">Manual</a>
<ul>
<li><a href="#org46c5f44">Prerequisites</a></li>
<li><a href="#org676b6f8">PKM</a>
<ul>
<li><a href="#org3f818ad">Principles</a></li>
<li><a href="#org5f1ef7d">Methods</a></li>
</ul>
</li>
<li><a href="#org1c781af">PKM with LLM</a>
<ul>
<li><a href="#orgc2825a2">Ollama</a></li>
<li><a href="#orgf5aa9b0">Open WebUI</a></li>
<li><a href="#org35a2f23"><b>Kotaemon</b></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org54cc18c">Thanks</a></li>
</ul>
</div>
</nav>
<div id="outline-container-org4ec2526" class="outline-2">
<h2 id="org4ec2526">Intro</h2>
<div class="outline-text-2" id="text-org4ec2526">
<p>
在之前的使用 nb 的时候已经在琢磨使用bash脚本来做笔记的框架。期间因为没有找到有效的处理双链和反链的方法，无意间了解到了Emacs里的org-roam可以提供反链，正好又在学习代码的初期急需一个编辑器，于是在Emacs还是Nvim之间选择了Emacs。
</p>

<p>
直到这几天无意间发现了<a href="https://github.com/vimwiki/vimwiki">vimwiki/vimwiki: Personal Wiki for Vim</a>，如果当初的搜索关键字多了几个字，这几个月关于做笔记的探索将会截然不同。
</p>

<p>
想 <b>脱离笔记软件</b> 回归数据本身，这是当初停止使用Logseq、obsidian的最大原因。
</p>

<p>
<a href="https://mischavandenburg.com/zet/neovim-zettelkasten/">我的 Neovim Zettelkasten：我如何使用 Vim 和 Bash 在 Markdown 中做笔记 |米沙·范登伯格</a> ，随即搜到了这篇文章，让我决定开始尝试Nvim做笔记的方案。Bash其实就是依赖性最小的工具。
</p>

<p>
org-capture可以用bash脚本来实现，双链通过VImwiki实现，反链同样可以通过bash脚本正则查询实现。在迁移配置到其他环境时Nvim的轻便优势就更大了，在我的Linux虚拟机里迁移一次DoomEmacs将近要安装配置半个多小时，而Nvim一个dotfile，5分钟搞定安装到配置。
</p>

<p>
Emacs是一个赛博乐高，我很享受这几个月使用Emacs收获的快乐，但它并不能完全扩展成一个兼容性很强的方法。
</p>

<p>
Emacs也完全是一个操作系统，对比起来Nvim作为编辑器的最大优势就在于轻巧。Org-mode里让我最喜欢的一点就是标题可折叠和自定义显示层级，对各种语言、格式的兼容性都很强。代码块部分可以直接生成结果，可以直接在代码块里使用jupyter，这对于做coding笔记来说很方便。再就是org-capture。它像是一个办公室。这里有书柜、办公桌、台灯，你可以在这里构建任何其他你喜欢的东西，但搬家是个大工程。
</p>

<p>
这些功能都依赖于Emacs、依赖于org-mode，用的越多，对它们的依赖就越大，因为Emacs和org真的很好用。 <code>.org</code> 文件转换起来并不麻烦，org基本可以输出成任何其他格式的文件，但迁移之后也就失去了org的功能特性。
</p>

<p>
Notion、Logseq、Obsidian、Roam Research、Heptabase，未来还会有更多的笔记软件，适合自己的才是最好的，选择一个笔记软件、笔记工具就是在选择一个生态、一个系统。你可能会想，既然有这么多成熟的笔记生态了，为什么还要自己折腾这些？因为这些就是他们当初不满意现有的生态，折腾出来的适合自己的笔记方法。我不太想依赖于别人的方法，下一个笔记软件，何必是笔记软件。
</p>

<p>
通过RAG将PKM和LLM结合起来一定以未来更有效的学习方式。结构化的文档有更少的噪声、清晰的数据结构和关系进、支持更复杂的SQL查询，进而从数据源头提高RAG向量化的质量。从数据层面来思考笔记的形式、回归数据本质是这次要继续探索的方向。PKM笔记文档和PostgreSQL链接起来是下一步要解决的问题。
</p>

<p>
这个手册主要介绍了以 Nvim 和 bash 脚本构建 PKM 体系的方法，供和我一样在 Nvim 和 Emacs 之间做过选择的兄弟们参考。
</p>

<p>
我现在依然是 Emacs 的重度使用者，脱离笔记软件并不是脱离某个具体的体系和产品，而是将这些体系变成自己的，进而脱离笔记软件和传统笔记方法的固定思维。现在在 Emacs 里，我依然会使用 bash 脚本来完成部分零散的笔记，例如结合我的 TiddlyWiki，快速构建 Markdown 笔记。
</p>

<p>
无论是 Emacs 还是 Nvim，它们都可以用 bash 脚本作为依赖最低的方法扩展自己记录笔记的方式。Nvim 和 Emacs 我真的都很喜欢，但是 org-mode 给我的编辑体验是其他任何其他纯文本形式替代不了的。
</p>

<p>
Vim 编辑模式、PKM方法才是那支笔，它们把笔记数据、操作系统链接起来，你可以在任何环境使用这只笔。忘掉所有招式就练成太极了。
</p>


<figure id="org2b4eb74">
<img src="https://testingcf.jsdelivr.net/gh/vandeefeng/gitbox@main/img/nvimdash.png" class="img" width="50%" height="50%">

</figure>
</div>
</div>
<div id="outline-container-orge1a15b1" class="outline-2">
<h2 id="orge1a15b1">Manual</h2>
<div class="outline-text-2" id="text-orge1a15b1">
<p>
这是一个以 <a href="https://neovim.io/">Neovim</a> 为基础编辑器、文件管理的Markdown本地笔记PKM。
</p>

<p>
本手册包括：
</p>

<ul class="org-ul">
<li>Prerequisites：开始构建本PKM需要的工具和准备工作</li>
<li>PKM：本PKM的构建原则和具体方法</li>
<li>PKM with LLM：PKM和大语言模型结合的使用</li>
</ul>
</div>
<div id="outline-container-org46c5f44" class="outline-3">
<h3 id="org46c5f44">Prerequisites</h3>
<div class="outline-text-3" id="text-org46c5f44">
<p>
Start with：<a href="https://git-scm.com/download">Git</a>，<a href="https://neovim.io/">Neovim</a>，<a href="https://github.com/LazyVim/LazyVim">LazyVim</a>，<a href="https://github.com/vimwiki/vimwiki">Vimwiki</a>，<a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a>，<a href="https://sw.kovidgoyal.net/kitty/">kitty</a> 或其他terminal。
</p>

<p>
开始你可能需要对Nvim，Markdown，Git，vim编辑模式有一些了解，这些可以帮助到你：
</p>

<ul class="org-ul">
<li><a href="https://neovim.io/doc/">Documentation - Neovim</a></li>
<li><a href="https://www.lazyvim.org/">🚀 Getting Started | LazyVim</a></li>
<li><a href="https://www.markdownguide.org/basic-syntax/">Basic Syntax | Markdown Guide</a></li>
<li><a href="https://github.com/topics/nvim">nvim · GitHub Topics</a></li>
<li><a href="https://github.com/LunarVim/Neovim-from-scratch">LunarVim/Neovim-from-scratch: 📚 A Neovim config designed from scratch to be understandable</a></li>
<li><a href="https://github.com/craftzdog/dotfiles-public">craftzdog/dotfiles-public: My personal dotfiles</a></li>
<li><a href="https://oi-wiki.org/tools/editor/vim/">Vim - OI Wiki</a></li>
<li><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程</a></li>
</ul>

<p>
不太建议上手Nvim就直接使用<a href="https://nvchad.com/">NvChad</a>这种类似于DoomEmacs的集成配置，它们的文件结构不利于自定义个性化配置。Nvim配置起来比Emacs简易许多，不太需要一步到位的集成方案。
</p>

<p>
<a href="https://github.com/LazyVim/LazyVim">LazyVim</a>既是一个插件安装管理器同时也是一个初始的简易Nvim配置，从这里开始。
</p>
</div>
</div>
<div id="outline-container-org676b6f8" class="outline-3">
<h3 id="org676b6f8">PKM</h3>
<div class="outline-text-3" id="text-org676b6f8">
<p>
整体的笔记文件管理结构，还是<a href="https://publish.obsidian.md/chinesehelp/01+2021%E6%96%B0%E6%95%99%E7%A8%8B/ACCESS%E7%AC%94%E8%AE%B0%E6%B3%95">ACCESS</a>，可以选择不用。有文件夹和没有文件夹是两种不同的管理模式，例如ob和Logseq。这个手册里更主要的是分享我在构建PKM的过程中迭代的一些原则和方法，以供参考，形成、巩固自己的方法才是这个手册真正的目的，remember：有形易于无形。具体可以参看：<a href="https://dg.vandee.art/Atlas/MOC/%C2%A7Vandee%E7%9A%84PKM">§Vandee的PKM</a>
</p>

<p>
Journals用来记录每天的日志，作为简单明了的回顾和展开。如果你不喜欢文件夹管理，我觉得这个是很有必要的。
</p>

<p>
在Nvim里，我暂时使用Bash脚本来创建Journals。以年月日展示，在Typora的侧边栏可以直观的选择特定日期的日志。为了展示MD标题层级的效果，脚本设置了在Typora里默认打开，可以根据需求更改。Nvim里正则搜索特定日期的标题就可以找到当天的日志了。
</p>


<figure id="org186abef">
<img src="https://testingcf.jsdelivr.net/gh/vandeefeng/gitbox@main/img/jounalbash.gif" class="img" width="50%" height="50%">

</figure>

<p>
核心： <b>原子笔记</b> + <b>双链</b> 。
</p>

<p>
你可能需要了解「 <b>原子笔记</b> 」（或者常青笔记，whatever）：<a href="https://notes.andymatuschak.org/zNUaiGAXp21eorsER1Jm9yU">Evergreen notes should be atomic</a>。
</p>

<p>
双链和反链让笔记之间的关联更加直观，当原子笔记很多的时候，反链可以直观的反应出和当前笔记相关的其他笔记。它应该同步于思维的链条。
</p>

<p>
Zettelkasten 其实并不那么重要。
</p>

<p>
Stay foolish，stay simple。
</p>

<p>
<b>关于同步</b> ：
</p>

<p>
本地笔记没有在线笔记软件方便的地方就是多端同步与预览。我的本地笔记已经上传到了GitHub仓库，通过Git同步。临时需要修改的直接在GitHub仓库里就修改了。预览方面，我的笔记输出到了<a href="https://dg.vandee.art/">Vandee's Digital Garden</a>。
</p>
</div>
<div id="outline-container-org3f818ad" class="outline-4">
<h4 id="org3f818ad">Principles</h4>
<div class="outline-text-4" id="text-org3f818ad">
<ul class="org-ul">
<li><a href="https://dg.vandee.art/Cards/%E4%B8%80%E4%B8%AA%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BC%98%E7%A7%80%E7%9A%84%E6%A3%80%E7%B4%A2%E9%80%BB%E8%BE%91">一个良好的知识循环系统，应该有优秀的检索逻辑</a></li>
<li><a href="https://dg.vandee.art/Cards/%E7%AC%94%E8%AE%B0%E6%98%AF%E6%80%9D%E7%BB%B4%E7%9A%84%E5%91%88%E7%8E%B0%EF%BC%8C%E5%AE%83%E5%BA%94%E8%AF%A5%E6%98%AF%E7%9F%A2%E9%87%8F%E7%9A%84">笔记是思维的呈现，它应该是矢量的</a>，当然也是<a href="https://notes.andymatuschak.org/zNUaiGAXp21eorsER1Jm9yU">原子化</a>的</li>
<li><a href="https://dg.vandee.art/Cards/%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%B2%E8%81%94%E5%BA%94%E8%AF%A5%E5%AE%8C%E5%85%A8%E4%BE%9D%E9%9D%A0%E4%B8%8E%E6%80%9D%E7%BB%B4%E7%9A%84%E5%90%8C%E6%AD%A5">笔记之间的串联应该完全依靠与思维的同步</a></li>
<li><a href="https://dg.vandee.art/Cards/%E7%AC%94%E8%AE%B0%E5%BA%94%E8%AF%A5%E8%AE%A9%E7%9F%A5%E8%AF%86%E6%B5%81%E5%8A%A8%E8%B5%B7%E6%9D%A5">笔记应该让知识流动起来</a></li>
<li><a href="https://dg.vandee.art/Cards/%E7%AC%94%E8%AE%B0%E5%BA%94%E8%AF%A5%E6%9C%89%E4%BC%98%E7%A7%80%E7%9A%84%E5%B1%82%E7%BA%A7%E9%80%BB%E8%BE%91">笔记应该有优秀的层级逻辑</a></li>
<li><a href="https://dg.vandee.art/Cards/%E7%AC%94%E8%AE%B0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E5%9C%A8%E4%BA%8E%E5%A2%9E%E6%8F%B4%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1">笔记的核心价值在于增援未来的自己</a></li>
</ul>

<p>
无思维不笔记，PKM不做本末倒置的事，让它帮助自己拓展思维，提升思维、学习、认知的效率，<a href="https://dg.vandee.art/Cards/%E6%89%BE%E5%88%B0%E7%9F%A5%E8%AF%86%E7%9A%84%E7%BC%9D%E9%9A%99">找到知识的缝隙</a>，更好的认知世界、认知自我才是本质。
</p>
</div>
</div>
<div id="outline-container-org5f1ef7d" class="outline-4">
<h4 id="org5f1ef7d">Methods</h4>
<div class="outline-text-4" id="text-org5f1ef7d">
<p>
在最开始需要构建的关键体系就是检索的逻辑。
</p>

<p>
在双链部分由于原则上已经和思维高度同步，因此不需要做额外的增加思维成本的检索，只要在记录原子笔记的时候，顺其自然，高度提炼出明确、简洁的一句话概念即可。
</p>

<p>
在标签tags部分，我习惯把标签当作是一个object的二、三级属性来看待。例如《黄金时代》这本书，它的基础属性是book，我不会再重复标注它，而是写在property里，记下 <code>Type: book</code> 方便我通过函数来列举所有的书目，tag则记下文学、王小波。我习惯用单数来强调它是个属性，区别与复数的category集合的概念。
</p>

<p>
我看过许多博客和PKM，许多情况下，他们的tags在语义概念上都混用了，我习惯把tags和categories分开，分类就是分类，标签就是标签。category、property、tag还是需要在逻辑里有自然的分类，理清楚一个概念的内涵与外延。混用会导致tags越来越多，成百上千的tags反而会增加检索的成本，过个几年，大多数的tags你已经忘了当时为什么记下了，单独再去整理标签无疑是个巨大的工程，tags也失去了应当有的作用。tags的构建同样应当同步与自身的思维习惯，自身对概念、语义的记忆。
</p>

<p>
当然这也完全取决于每个人自己的习惯。
</p>

<p>
学习、获取信息和知识是在做加法，PKM里更多的应该是减法，<a href="https://dg.vandee.art/Sources/Articles/Stay-learn,-Stay-unlearn%EF%BD%9C%E8%AF%95%E8%A1%8C%E9%94%99%E8%AF%AF102">Learn and unlearn</a>。
</p>

<p>
整体配置、配置文件结构参考：<a href="https://github.com/craftzdog/dotfiles-public">craftzdog/dotfiles-public: My personal dotfiles</a> 。
</p>
</div>
<ul class="org-ul">
<li><a id="org85d953d"></a>Vimwiki<br>
<div class="outline-text-5" id="text-org85d953d">
<p>
Vimwiki提供了类似于org-roam的insert功能，选中文字直接Enter即可在配置的笔记目录下生成笔记。当然也可以 <code>/path/notes</code> 的形式在相对路径的文件夹里生成对应文件。
</p>

<p>
VImwiki这个相对路径直接生成文件的实现很重要。在ob里可以直接 <code>[[note1][[note1]]</code> 或 <code>[note1]</code> 引用 <code>note1</code> ，但这在其他笔记软件里是不支持的。许多md博客生成框架例如hugo，是不支持这种全局通过文件名引用的。Vimwiki支持 <code>[[note1][/pkm/note1]]</code> 这样的格式，保留了相对路径在以后兼容其他框架的时候修改起来就很方便。
</p>

<p>
然后就可以开始愉快的写md笔记了。反链暂时我使用正则对当前文件名搜索，得到其他引用文件。Lua还不是很熟，后面写一个脚本来打印出搜索的结果。这个在Emacs里可以通过embark在minibuffer里实现。
</p>

<ul class="org-ul">
<li><p>
Lazy安装：
</p>

<p>
<code>{'vimwiki/vimwiki'}</code>
</p>

<p>
官方文档里，没有直接写明Lazy的安装方式，我还以为不支持，其实是支持的。
</p></li>

<li><p>
配置笔记文件夹
</p>

<div class="org-src-container">
<pre class="src src-lua">-- vim
let g:vimwiki_list = [{'path': '~/vimwiki/',
                      \ 'syntax': 'markdown', 'ext': 'md'}]
-- lua
vim.g.vimwiki_list = {
  {
    path = '~/vimwiki/',
    syntax = 'markdown',
    ext = 'md'
  }
}</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org0bc1c60"></a>Bash - MD capture<br>
<div class="outline-text-5" id="text-org0bc1c60">
<p>
我现在自用的bash脚本包括导航脚本和特定笔记脚本两种，根据这两个模板常用的笔记需求基本可以满足。基本复现org-capture里自定义模板、特定位置写入内容、指定文件生成位置。
</p>


<figure id="orgb788bb6">
<img src="https://testingcf.jsdelivr.net/gh/vandeefeng/gitbox@main/img/mdnotesbash.gif" class="img" width="50%" height="50%">

</figure>
</div>
<ul class="org-ul">
<li><a id="org0acebd9"></a>使用Bash脚本步骤<br>
<div class="outline-text-6" id="text-org0acebd9">
<ul class="org-ul">
<li>添加脚本文件夹环境全局访问： <code>.bash_profile</code>  or  <code>.bashrc</code> 文件里写入 <code>export PATH="~/path/my_scripts:$PATH"</code></li>

<li>添加脚本可执行权限：terminal里 <code>cd ~/path/my_scripts</code> 到脚本文件夹位置， <code>chmod +x script_name.sh</code></li>
<li>添加别名： <code>alias script_alias='path/my_scripts/script_name.sh'</code> ，然后 <code>source ~/.bash_profile</code>  or  <code>source ~/.bashrc</code></li>

<li>Nvim里打开terminal或直接打开系统terminal，输入脚本名字或别名。</li>

<li>如果使用的是Homebrew安装的Bash，在脚本里替换 <code>#!/bin/bash</code> 为 <code>#!/opt/homebrew/bin/bash</code></li>
</ul>
</div>
</li>
<li><a id="org34f03e0"></a>脚本模板参考<br>
<div class="outline-text-6" id="text-org34f03e0">
<ul class="org-ul">
<li><p>
导航脚本，选择创建笔记的类型：
</p>

<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# 设置退出脚本的陷阱
trap 'echo "退出脚本。"; exit' SIGINT
# 定义脚本目录
script_dir="$HOME/path/"
# 定义操作和对应的脚本
declare -A operations=(
  [1]="Journals.sh"
  [2]="NotesMD.sh"
  [3]="AtomicMD.sh"
  [4]="BlogMD.sh"
)
# 显示操作选择列表并提示用户输入
echo "请选择要执行的操作（输入序号）:"
for i in $(seq 1 ${#operations[@]}); do
  echo "$i. ${operations[$i]}"
done
echo "或者输入 'q' 退出脚本"
# 读取用户输入
read -p "输入序号: " choice
# 检查用户是否选择退出脚本
if [[ "$choice" == "q" ]]; then
  echo "退出脚本。"
  exit
fi
# 根据用户输入的序号执行相应的脚本
if [[ -n "${operations[$choice]}" ]]; then
  script_path="${script_dir}${operations[$choice]}"
  echo "执行 ${operations[$choice]} 脚本..."
  # 执行相应的脚本
  "$script_path"
else
  echo "无效的序号，请输入1到4之间的数字。"
  exit 1
fi
# 提醒用户已执行相应脚本
echo "已执行选择的脚本。"</pre>
</div></li>
<li><p>
Journal脚本，生成每天的日志：
</p>

<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# 设置系统语言环境为英文
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
# 设置绝对路径
base_path="$HOME/path/Journals"
# 获取当前年份
current_year=$(date +"%Y")
# 询问用户输入日期
read -p "Please enter the date (YYYY-MM-DD or MM-DD) [default: $(date +"%Y-%m-%d")], or 'q' to quit: " input_date
# 如果用户输入 'q'，则退出脚本
if [ "$input_date" == "q" ]; then
    echo "Exiting the script."
    exit 0
fi
# 如果用户没有输入日期，则使用当天日期
if [ -z "$input_date" ]; then
    input_date=$(date +"%Y-%m-%d")
fi
# 检查输入格式
if [[ $input_date =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})$ ]]; then
    # 完整的 YYYY-MM-DD 格式
    input_year=$(echo "$input_date" | cut -d'-' -f1)
    input_month=$(echo "$input_date" | cut -d'-' -f2)
    input_day=$(echo "$input_date" | cut -d'-' -f3)
elif [[ $input_date =~ ^([0-9]{2})-([0-9]{2})$ ]]; then
    # MM-DD 格式，使用当前年份
    input_year=$current_year
    input_month=$(echo "$input_date" | cut -d'-' -f1)
    input_day=$(echo "$input_date" | cut -d'-' -f2)
else
    echo "Invalid date format. Please use YYYY-MM-DD or MM-DD."
    exit 1
fi
# 生成 Journal 文件路径
journal_filename="Journal-$input_year.md"
journal_path="$base_path/$journal_filename"
# 检查文件是否已存在
if [ -f "$journal_path" ]; then
    echo "Journal file already exists: $journal_path"
    target_file="$journal_path"
else
    touch "$journal_path"
    echo "Journal file created: $journal_path"
    target_file="$journal_path"
fi
# 获取当前日期信息
current_date=$(date +"%Y-%m-%d")
current_month_name=$(date +"%b")
current_day_name=$(date +"%A")
# 使用 date 命令获取输入日期的月份和星期几的名称
input_month_name=$(date -j -f "%Y-%m-%d" "$input_year-$input_month-$input_day" +"%b")
input_day_name=$(date -j -f "%Y-%m-%d" "$input_year-$input_month-$input_day" +"%A")
# 检查当前年份头是否存在
if ! grep -q "# $input_year" "$target_file"; then
    echo "# $input_year" >> "$target_file"
    echo "Current year header inserted in $target_file: # $input_year"
else
    echo "Current year header already exists, no need to insert it again"
fi
# 检查当前月份头是否存在
if ! grep -q "## $input_year-$input_month $input_month_name" "$target_file"; then
    echo "## $input_year-$input_month $input_month_name" >> "$target_file"
    echo "Current month header inserted in $target_file: ## $input_year-$input_month $input_month_name"
else
    echo "Current month header already exists, no need to insert it again"
fi
# 检查当前日期头是否存在
if ! grep -q "### $input_year-$input_month-$input_day $input_day_name" "$target_file"; then
    echo "### $input_year-$input_month-$input_day $input_day_name" >> "$target_file"
    echo "Current day of the week header inserted in $target_file: ### $input_year-$input_month-$input_day $input_day_name"
    echo "" >> "$target_file"
    echo "- TODOs" >> "$target_file"
    echo "- Inbox" >> "$target_file"
    # 将光标定位在"- Inbox"这一行
    sed -i '' -e '/- Inbox/G' "$target_file"
else
    echo "Current day of the week header already exists"
fi
# 用Typora打开生成的日记文件
open -a Typora "$target_file"</pre>
</div></li>

<li><p>
Notes脚本，生成一般的笔记：
</p>

<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# 提示用户输入Markdown文件的名称，并检查是否输入了"q"以退出脚本
while true; do
  read -p "请输入Markdown文件的名称（不包含.md扩展名）或输入'q'退出: " filename
  if [[ "$filename" == "q" ]]; then
    echo "退出脚本。"
    exit
  fi
  # 如果用户没有输入任何内容，则使用当前日期和时间作为文件名
  filename=${filename:-$(date '+%Y%m%d%H%M%S')}
  # 检查输入是否有效，如果为空则继续询问
  if [ -z "$filename" ]; then
    echo "文件名不能为空，请输入文件名或输入'q'退出。"
    continue
  fi
  # 一旦获得有效输入，跳出循环
  break
done
# 检查是否已经存在该目录，如果不存在则创建
mdNotesDir="$HOME/path/"
if [ ! -d "$mdNotesDir" ]; then
  mkdir -p "$mdNotesDir"
fi
# 构建完整的文件路径
fullPath="${mdNotesDir}${filename}.md"
# 获取当前的日期和时间
current_date=$(date '+%Y-%m-%d')
current_date_yyyyMMddHHmmss=$(date '+%Y%m%d%H%M%S')
# 创建并写入 YAML 头信息到 Markdown 文件
cat > "$fullPath" <<EOF
---
UID: $current_date_yyyyMMddHHmmss
title: $filename
alias:
areas:
tags:
rank:
source:
type: Article
date: $current_date
---
EOF
# 提醒用户文件已创建
echo "Markdown 文件 '$fullPath' 已创建。"
# 使用 open 命令自动打开文件
open -a "typora" "$fullPath"</pre>
</div></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org7fca71e"></a>ToggleTerm<br>
<div class="outline-text-5" id="text-org7fca71e">

<figure id="orgc9aa42c">
<img src="https://testingcf.jsdelivr.net/gh/vandeefeng/gitbox@main/img/bash-quote.gif" class="img" width="50%" height="50%">

</figure>

<p>
<a href="https://github.com/akinsho/toggleterm.nvim">akinsho/toggleterm.nvim</a> 可以在Nvim里快速创建一个内置终端。结合Bash脚本，体验和Emacs里使用org-capture差不多。当然，org-capture可以结合org-protocol，还是要强大太多。
</p>

<ul class="org-ul">
<li><p>
安装：
</p>

<div class="org-src-container">
<pre class="src src-lua">  {
    -- amongst your other plugins
    {'akinsho/toggleterm.nvim', version = "*", config = true}
    -- or
    {'akinsho/toggleterm.nvim', version = "*", opts = {--[[ things you want to change go here]]}}
  }</pre>
</div></li>
<li><p>
参考配置：
</p>

<div class="org-src-container">
<pre class="src src-lua">local toggleterm = require("toggleterm")
  toggleterm.setup({
      size = 15, - 设置窗口大小
      open_mapping = "<C-\\>",
      start_in_insert = true,
      direction = "horizontal", - 设置窗口横向或竖向
      shell = vim.o.shell, - 设置需要使用的shell
  })
  - 在Terminal里使用vim的移动指令
  function _G.set_terminal_keymaps()
    local opts = { noremap = true }
    vim.api.nvim_buf_set_keymap(0, 't', '<esc>', [[<C-\><C-n>]], opts)
    vim.api.nvim_buf_set_keymap(0, 't', 'jk', [[<C-\><C-n>]], opts)
    vim.api.nvim_buf_set_keymap(0, 't', '<C-h>', [[<C-\><C-n><C-W>h]], opts)
    vim.api.nvim_buf_set_keymap(0, 't', '<C-j>', [[<C-\><C-n><C-W>j]], opts)
    vim.api.nvim_buf_set_keymap(0, 't', '<C-k>', [[<C-\><C-n><C-W>k]], opts)
    vim.api.nvim_buf_set_keymap(0, 't', '<C-l>', [[<C-\><C-n><C-W>l]], opts)
  end
  vim.cmd('autocmd! TermOpen term://* lua set_terminal_keymaps()')
  local Terminal = require("toggleterm.terminal").Terminal
  local lazygit = Terminal:new({ cmd = "lazygit", hidden = true })
  function _LAZYGIT_TOGGLE()
    lazygit:toggle()
  end
  local node = Terminal:new({ cmd = "node", hidden = true })
  function _NODE_TOGGLE()
    node:toggle()
  end
  local python = Terminal:new({ cmd = "python3", hidden = true })
  function _PYTHON_TOGGLE()
    python:toggle()
  end
  -- 为 Python 终端设置快捷键
  vim.api.nvim_set_keymap('n', '<leader>tp', ':lua _PYTHON_TOGGLE()<CR>', { noremap = true, silent = true })
  -- 快速打开Terminal
  vim.keymap.set("n", "<Leader>tt", function()
    require("toggleterm").toggle()
  end, { desc = "ToggleTerm" })
  -- end</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="orgb3e8a5b"></a>中英输入法问题<br>
<ul class="org-ul">
<li><a id="org0e6b90a"></a>im-select-nvim<br>
<div class="outline-text-6" id="text-org0e6b90a">
<p>
<a href="https://github.com/keaising/im-select.nvim">keaising/im-select.nvim</a> 这个插件可以在Nvim里让nomal模式下自动切换成英文输入，在insert模式下自动切换回中文输入。刚需。
</p>
<ul class="org-ul">
<li><p>
先安装im-select
</p>

<div class="org-src-container">
<pre class="src src-bash">Install
Download URL: https://github.com/daipeihust/im-select
Check installation in bash/zsh
# find binary
$ which im-select
# Get current im name
$ im-select
# Try to switch to English keyboard
$ im-select com.apple.keylayout.ABC
Check in NeoVim
:!which im-select</pre>
</div></li>

<li><p>
im-select-nvim的安装和配置
</p>

<div class="org-src-container">
<pre class="src src-lua">{
    "keaising/im-select.nvim",
    config = function()
        require('im_select').setup({
            -- IM will be set to `default_im_select` in `normal` mode
            -- For Windows/WSL, default: "1033", aka: English US Keyboard
            -- For macOS, default: "com.apple.keylayout.ABC", aka: US
            -- For Linux, default:
            --               "keyboard-us" for Fcitx5
            --               "1" for Fcitx
            --               "xkb:us::eng" for ibus
            -- You can use `im-select` or `fcitx5-remote -n` to get the IM's name
            default_im_select  = "com.apple.keylayout.ABC",
            -- Can be binary's name, binary's full path, or a table, e.g. 'im-select',
            -- '/usr/local/bin/im-select' for binary without extra arguments,
            -- or { "AIMSwitcher.exe", "--imm" } for binary need extra arguments to work.
            -- For Windows/WSL, default: "im-select.exe"
            -- For macOS, default: "im-select"
            -- For Linux, default: "fcitx5-remote" or "fcitx-remote" or "ibus"
            default_command = "/opt/homebrew/bin/im-select",
            -- Restore the default input method state when the following events are triggered
            set_default_events = { "VimEnter", "FocusGained", "InsertLeave", "CmdlineLeave" },
            -- Restore the previous used input method state when the following events
            -- are triggered, if you don't want to restore previous used im in Insert mode,
            -- e.g. deprecated `disable_auto_restore = 1`, just let it empty
            -- as `set_previous_events = {}`
            set_previous_events = { "InsertEnter" },
            -- Show notification about how to install executable binary when binary missed
            keep_quiet_on_no_binary = false,
            -- Async run `default_command` to switch IM or not
            async_switch_im = true
        })
    end,
},</pre>
</div></li>
</ul>

<p>
Ref:
</p>
<ul class="org-ul">
<li><a href="https://github.com/lei4519/blog/issues/85">完善 Rime Vim Mode：支持 Linux &amp; 自动切换回中文模式 · Issue #85 · lei4519/blog</a></li>
<li><a href="https://sspai.com/post/71322">Vim 的中文支持及解决思路 - 少数派</a></li>
<li><a href="https://jdhao.github.io/2021/02/25/nvim_ime_mode_auto_switch/">如何让 Neovim 中文输入时自动切换输入法 · Blowfish</a></li>
</ul>
</div>
</li>
<li><a id="orga54852f"></a>RIME<br>
<div class="outline-text-6" id="text-orga54852f">
<p>
如果说PKM是纸，那么输入法就是笔。
</p>

<p>
再次强烈推荐 <a href="https://rime.im/">RIME | 中州韻輸入法引擎</a>，配合 <a href="https://github.com/iDvel/rime-ice">iDvel/rime-ice: Rime 配置：雾凇拼音 | 长期维护的简体词库</a>，多平台多端同步。已经使用了几年，非常巴适，手机端也可以同步配置。
</p>

<p>
以前输入法就各种偷偷记录用户输入习惯，现在各个输入法又还要内置AI再记录一遍。本地配置、不需要联网的输入法是我的刚需，更何况，rime还可以自挂词库。
</p>

<p>
一个巨坑，最近的RIME更新在<a href="https://github.com/rime/squirrel/releases/tag/1.0.0">Release 1.0.0 · rime/squirrel</a>版本里改变了候选词横向和竖向的设置：
</p>

<div class="org-src-container">
<pre class="src src-nil">style/horizontal 將徹底移除，雖然本版程序仍支持，但會被新控件的默認值覆蓋
請使用 candidate_list_layout: stacked/linear 和 text_orientation: horizontal/vertical</pre>
</div>

<p>
而且最好直接在输入法外观的配置文件里，修改输入法外观的配置，而不是通用配置，反正我在通用设置里不起作用。
</p>

<p>
<b>下面是简单的安装步骤</b> ：
</p>

<div class="org-src-container">
<pre class="src src-bash">;; mac:
;; mac rime: https://rime.im/download/
Homebrew: brew install --cask squirrel
或者直接下载
;; mac rime-ice
使用东风破 plum 安装: https://github.com/rime/plum
curl -fsSL https://raw.githubusercontent.com/rime/plum/master/rime-install | bash
安装 rime-ice:
℞ 安装或更新全部文件
bash rime-install iDvel/rime-ice:others/recipes/full
℞ 安装或更新所有词库文件（包含下面三个）
bash rime-install iDvel/rime-ice:others/recipes/all_dicts
℞ 安装或更新拼音词库文件（ cn_dicts/ 目录内所有文件）
bash rime-install iDvel/rime-ice:others/recipes/cn_dicts
℞ 安装或更新英文词库文件（ en_dicts/ 目录内所有文件）
bash rime-install iDvel/rime-ice:others/recipes/en_dicts
℞ 安装或更新 opencc （ opencc/ 目录内所有文件）
bash rime-install iDvel/rime-ice:others/recipes/opencc
;;或使用 rime-auto-deploy：https://github.com/Mark24Code/rime-auto-deploy，这个和plum只用选一个。
=======================================================
;;Linux
ibus:
https://github.com/rime/home/wiki/RimeWithIBus
sudo apt-get install ibus-rime                   #ibus
fcitx5:
sudo pacman -Sy fcitx5-rime                      # Arch Linux
sudo apt update && sudo apt install fcitx5-rime  # Ubuntu / Debian / Deepin
sudo zypper install fcitx5-rime                  # OpenSUSE
sudo dnf install fcitx5-rime                     # Fedora
plum and rime-ice：
git clone --depth 1 https://github.com/rime/plum ~/plum
;; 切换到东风破的目录
cd ~/plum
;; 如果你使用Fcitx5，你需要加入参数，让东风破把配置文件写到正确的位置
rime_frontend=fcitx5-rime bash rime-install iDvel/rime-ice:others/recipes/full
;; 如果你是用IBus，则不需加参数，因为东风破默认是为IBus版的RIME打造。
bash rime-install iDvel/rime-ice:others/recipes/full</pre>
</div>


<p>
其他可以参考下面的文章:
</p>

<ul class="org-ul">
<li><a href="https://sspai.com/post/84373#!">自由输入法 RIME 简明配置指南 - 少数派</a></li>

<li><a href="https://sspai.com/post/89281">RIME + 雾凇拼音，打造绝佳的开源文字输入体验 - 少数派</a></li>

<li><a href="https://sspai.com/post/90068">让 RIME 体验更上一层楼：如何用 MediaWiki 扩展词库 - 少数派</a>  导入wiki</li>

<li><a href="https://github.com/gshang2017/rime-dict">gshang2017/rime-dict: RIME输入法(拼音)自用词库(包含英语，基础，维基，搜狗等词库)，词频基于腾讯AI向量词库逆序生成。</a>  自建词库，导入专业领域词汇</li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="orga26f03b"></a>MarkdownPreview<br>
<div class="outline-text-5" id="text-orga26f03b">
<p>
<a href="https://github.com/iamcco/markdown-preview.nvim">iamcco/markdown-preview.nvim</a>提供实时的markdown预览，对于经常写md的不是那么必须，拿不准的可以预览看看的整体效果。输入 <code>:MarkdownPreview</code> 就会在浏览器里打开预览。
</p>

<p>
当然，还有个更简单的办法，在Typora里打开:
</p>

<div class="org-src-container">
<pre class="src src-lua">
-- 定义一个函数,用于在 Typora 中打开当前缓冲区文件 --
local function open_with_typora()
    local current_file = vim.api.nvim_buf_get_name(0)
    vim.cmd('!open -a Typora "' .. current_file .. '"')
end
-- 将该函数绑定到 <leader>t 快捷键
vim.keymap.set('n', '<leader>fo', open_with_typora, { desc = 'Open current buffer in Typora' })
-- end</pre>
</div>

<ul class="org-ul">
<li><p>
安装
</p>

<p>
在Nvim里使用Lazy安装会报错，这个 <a href="https://github.com/iamcco/markdown-preview.nvim/issues/690">issue</a> 给出了解决办法：
</p>

<div class="org-src-container">
<pre class="src src-lua">  {
    -- Install markdown preview, use npx if available.
    "iamcco/markdown-preview.nvim",
    cmd = { "MarkdownPreviewToggle", "MarkdownPreview", "MarkdownPreviewStop" },
    ft = { "markdown" },
    build = function(plugin)
      if vim.fn.executable "npx" then
        vim.cmd("!cd " .. plugin.dir .. " && cd app && npx --yes yarn install")
      else
        vim.cmd [[Lazy load markdown-preview.nvim]]
        vim.fn["mkdp#util#install"]()
      end
    end,
    init = function()
      if vim.fn.executable "npx" then vim.g.mkdp_filetypes = { "markdown" } end
    end,
  },</pre>
</div></li>

<li><p>
配置
</p>

<p>
其他的基本不用怎么配置，下面是指定浏览器的配置：
</p>

<div class="org-src-container">
<pre class="src src-nil">Add the following to your Neovim init script:
Linux
  function OpenMarkdownPreview (url)
    execute "silent ! firefox --new-window " . a:url
  endfunction
  let g:mkdp_browserfunc = 'OpenMarkdownPreview'
Replace firefox with chrome if you prefer. Both browsers recognize the --new-window option.
macOS
  function OpenMarkdownPreview (url)
    execute "silent ! open -a Firefox -n --args --new-window " . a:url
  endfunction
  let g:mkdp_browserfunc = 'OpenMarkdownPreview'
Replace Firefox with Google\ Chrome or Brave\ Browser if you prefer. They all recognize the --new-window option.</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org4a24602"></a>网页摘录和after-reading<br>
<div class="outline-text-5" id="text-org4a24602">
<p>
利用org-capture，做剪藏和摘录很方便。现在保存在~clip.org~文件里，可以在agenda里按时间线回顾，由于agenda里只有标题，也起到了类似Anki卡片回顾的作用：
</p>

<p>
有一个JavaScript我一直在用，可以选定一个网页的特定内容，在翻译和剪藏的时候挺有用，同时也微微提升了一点阅读体验。我用 <a href="https://github.com/OwO-Network/DeepLX">DeepLX</a>  通过沉浸式翻译如果单次翻译内容太多会报错和限制，Deepl的中文翻译还是吊打其他的。
</p>

<p>
下面的代码保存到书签，单击书签就可以了：
</p>

<div class="org-src-container">
<pre class="src src-nil">javascript:(function(){var e=document.body;const n=document.head.appendChild(document.createElement("style"));n.textContent=".mainonly { outline: 2px solid red; }";const t=CSS.supports("selector(:has(*))");function o(n){n instanceof HTMLElement&&(e.classList.remove("mainonly"),(e=n).classList.add("mainonly"))}function s(e){o(e.target)}function a(o){if(o.preventDefault(),t)n.textContent=":not(:has(.mainonly), .mainonly, .mainonly *) { display: none; }";else{n.textContent=":not(.mainonly *, .mainonly-ancestor) { display: none; }";var s=e;do{s.classList.add("mainonly-ancestor")}while(s=s.parentElement)}l()}function i(n){n.preventDefault(),n.deltaY<0?o(e.parentElement):o(e.firstElementChild)}function l(){document.removeEventListener("mouseover",s),document.removeEventListener("click",a),document.removeEventListener("wheel",i)}document.addEventListener("mouseover",s),document.addEventListener("click",a),document.addEventListener("wheel",i,{passive:!1}),document.addEventListener("keydown",(function o(s){if("Escape"===s.key&&(n.remove(),document.removeEventListener("keydown",o),l(),e?.classList.remove("mainonly"),!t))for(const e of document.getElementsByClassName("mainonly-ancestor"))e.classList.remove("mainonly-ancestor")}))}())</pre>
</div>

<p>
after-reading我一直用的 <a href="https://docs.omnivore.app/zh/">Omnivore</a>，开源免费，支持RSS和Newsletter，可以自动同步高亮标注、摘录到Obsidian和Logseq。这部分用来做 <a href="https://www.vandee.art/posts/2024-06-18-%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BF%9D%E9%B2%9C%E6%9C%9F-%E6%B5%81%E5%8A%A8%E7%9F%A5%E8%AF%86%E7%9A%84%E6%A3%80%E7%B4%A2/">流动知识的检索</a>，文档+RAG现在的项目也越来越多了。用AI来过滤、总结这些信息流很巴适。
</p>

<p>
简单写了一个python用来直接获取高亮摘录并与本地LLM问答：<a href="https://www.vandee.art/posts/2024-07-08-omnivore-with-llm-in-python/">RSS 订阅和本地 LLM 结合的初步尝试 - 流动知识检索 | Vandee's Blog</a>
</p>

<p>
有条件直接上 <a href="https://readwise.io/">Readwise</a>，配合Notion、Obsidian、Logseq都挺好用。<a href="https://getpocket.com/home?src=navbar">Pocket</a>、<a href="https://github.com/usememos/memos">memos</a> 也挺不错，可以把阅读整合到PKM里。
</p>

<p>
<a href="https://n8n.akashio.com/welcome">欢迎来到 n8n 中文教程 | 简单易懂的现代魔法</a>这里给出了一个 omnivore 到 notion 的 workflow。
</p>

<p>
最近<a href="https://www.vandee.art/posts/2024-07-24-start-to-get-readwies/">还是入坑了 Readwise</a>。
</p>
</div>
<ul class="org-ul">
<li><a id="org033df98"></a>tools<br>
<div class="outline-text-6" id="text-org033df98">
<ul class="org-ul">
<li><p>
网站：<a href="https://jina.ai/reader/">https://jina.ai/reader/</a>
</p>

<p>
Github：<a href="https://github.com/jina-ai/reader">https://github.com/jina-ai/reader</a>
</p>

<p>
它可以提取网页内容并转换为markdown格式，还支持直接搜索，支持API。
</p>

<p>
Reader does two things:
</p>

<ul class="org-ul">
<li><b>Read</b>: It converts any URL to an <b>LLM-friendly</b> input with <code>https://r.jina.ai/https://your.url</code>. Get improved output for your agent and RAG systems at no cost.</li>
<li><b>Search</b>: It searches the web for a given query with <code>https://s.jina.ai/your+query</code>. This allows your LLMs to access the latest world knowledge from the web.</li>
</ul>

<p>
添加下面代码到书签保存，点击书签就可以提取网页内容到markdown格式了。
</p>

<div class="org-src-container">
<pre class="src src-javascript">  javascript: var currentUrl = window.location.href;var newUrl = "https://r.jina.ai/" + currentUrl;window.open(newUrl, '_blank');window.history.pushState({}, '', currentUrl);</pre>
</div></li>
</ul>


<p>
以这个工具为跳板，就可以干许多有意思的事情了。
</p>

<ul class="org-ul">
<li><a href="https://github.com/JimmyLv/BibiGPT-v1">JimmyLv/BibiGPT-v1</a> 这个项目可以自己部署，总结B站、YouTube、抖音等等的视频内容，挺好用。</li>

<li><a href="https://sspai.com/post/89828">u-Sir/drag-to-preview</a>，最近发现一个Firefox浏览器插件，可以选中网页链接拖拽弹出单独的窗口预览网页，在窗口外区域鼠标点击即可关闭，很符合我的胃口。</li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1c781af" class="outline-3">
<h3 id="org1c781af">PKM with LLM</h3>
<div class="outline-text-3" id="text-org1c781af">
<p>
本地笔记的优势除了隐私性，再就是，数据在自己手上，就可以干很多事。把本地的笔记文档结合LLM做思维拓展，基于个人思维习惯更精确的问答。如果说有时候双链不足以串联整个思维链条，下面这些工具如虎添翼。
</p>

<p>
看到一个大佬已经用Ollama、RAG在MacBook Pro M3 Max上实现了基于obsidian的个人AI知识助手：<a href="https://lopespm.com/machine_learning/2024/06/24/personal-llm.html">个人本地 (Llama3 8B) LLM 使用 WhatsApp + Obsidian 数据扩展 - Byte Tank</a>，和我的思路基本一致。
</p>

<p>
简单写了一个python用来直接获取高亮摘录并与本地LLM问答：<a href="https://www.vandee.art/posts/2024-07-08-omnivore-with-llm-in-python/">RSS 订阅和本地 LLM 结合的初步尝试 - 流动知识检索 | Vandee's Blog</a>
</p>

<p>
很久之前，看到一篇文章提出了一个观点：随着和LLM互动的增多，特别是现在各种LLM平台，ChatGPT、Claude、perplexity等等，查询、回顾、汇总这些问答是一个值得注意的点。
</p>

<p>
现在我的日常问答都在本地使用Open WebUI，可以导出聊天还有数据库可以直接备份，甚至还可以给对话打tag，当然也可以搜索。
</p>
</div>
<div id="outline-container-orgc2825a2" class="outline-4">
<h4 id="orgc2825a2">Ollama</h4>
<div class="outline-text-4" id="text-orgc2825a2">
<p>
<a href="https://ollama.com/">Ollama</a> 可以本地部署大语言模型，目前GitHub 69.1k star，一直在用。obsidian，Emacs，Logseq都支持。如果说Cloudflare是赛博活菩萨，那ollama就是LLM筋斗云。
</p>

<p>
ollama支持主流的开源模型如llama3，所有支持模型可查看：
</p>

<p>
<b>Model library</b> ：Ollama supports a list of models available on <a href="https://ollama.com/library">ollama.com/library</a>
</p>

<p>
相关文章：
</p>

<ul class="org-ul">
<li><a href="https://blog.inoki.cc/2024/04/16/Ollama-cn/">Ollama 架构解析 | Inoki in the world</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgf5aa9b0" class="outline-4">
<h4 id="orgf5aa9b0">Open WebUI</h4>
<div class="outline-text-4" id="text-orgf5aa9b0">
<p>
<a href="https://github.com/open-webui/open-webui">Open WebUI</a> 提供一个WebUI运行本地LLM，目前GitHub 31k star。良好的兼容ollama，聊天数据本地保存，可本地导入文档做RAG查询。
</p>

<p>
<a href="https://openwebui.com/#open-webui-community">社区</a>提供了插件和功能，质变的是：可以让本地LLM搜索web的内容。
</p>

<p>
Open WebUI 在2024-10-06的版本中<a href="https://github.com/open-webui/open-webui/releases/tag/v0.3.31">更新</a>了支持类似Claude artifacts的artifacts: <b>🎨 Artifacts Feature</b>: Render web content and SVGs directly in the interface, supporting quick iterations and live changes，不过只支持原生的HTML和CSS。还更新了Overview，可以在白板里展示对话的内容，太实用了，史诗级更新！
</p>

<p>
*其他主要功能*：
</p>

<ul class="org-ul">
<li>📚 本地 RAG 集成：通过突破性的检索增强生成 (RAG) 支持深入探索聊天交互的未来。此功能将文档交互无缝集成到您的聊天体验中。您可以将文档直接加载到聊天中或将文件添加到文档库中，在查询之前使用 <code>#</code> 命令轻松访问它们。</li>

<li>🔍 RAG 的网络搜索：使用 <code>SearXNG</code> 、 <code>Google PSE</code> 、 <code>Brave Search</code> 、 <code>serpstack</code> 、 <code>serper</code> 、 <code>Serply</code> 、 <code>DuckDuckGo</code> 和 <code>TavilySearch</code> 并将结果直接注入您的聊天体验中。</li>

<li>🌐 网页浏览功能：使用 <code>#</code> 命令后跟 URL，将网站无缝集成到您的聊天体验中。此功能允许您将网络内容直接合并到您的对话中，从而增强交互的丰富性和深度。</li>
</ul>

<p>
<b>docker部署相当简单</b> ：
</p>

<ul class="org-ul">
<li>CLI: <code>docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</code></li>

<li><p>
Docker compose: <a href="https://github.com/open-webui/open-webui/blob/main/docker-compose.yaml">https://github.com/open-webui/open-webui/blob/main/docker-compose.yaml</a>
</p>

<div class="org-src-container">
<pre class="src src-yaml">services:
    ollama:
      volumes:
        - ollama:/root/.ollama
      container_name: ollama
      pull_policy: always
      tty: true
      restart: unless-stopped
      image: ollama/ollama:${OLLAMA_DOCKER_TAG-latest}
    open-webui:
      build:
        context: .
        args:
          OLLAMA_BASE_URL: '/ollama'
        dockerfile: Dockerfile
      image: ghcr.io/open-webui/open-webui:${WEBUI_DOCKER_TAG-main}
      container_name: open-webui
      volumes:
        - open-webui:/app/backend/data
      depends_on:
        - ollama
      ports:
        - ${OPEN_WEBUI_PORT-3000}:8080
      environment:
        - 'OLLAMA_BASE_URL=http://ollama:11434'
        - 'WEBUI_SECRET_KEY='
      extra_hosts:
        - host.docker.internal:host-gateway
      restart: unless-stopped
  volumes:
    ollama: {}
    open-webui: {}</pre>
</div></li>

<li><a href="https://docs.openwebui.com/getting-started/updating"> Updating | Open WebUI</a></li>
</ul>

<p>
Ref：<a href="https://docs.openwebui.com/">Open WebUI 官方手册</a>
</p>
</div>
</div>
<div id="outline-container-org35a2f23" class="outline-4">
<h4 id="org35a2f23"><b>Kotaemon</b></h4>
<div class="outline-text-4" id="text-org35a2f23">
<p>
从发现到现在差不多就一个多星期，GitHub直接飙升到10.9K star，win、mac、Linux都支持。边用边学习它的RAG构建框架，支持ollama，支持docker。
</p>

<p>
GitHub: <a href="https://github.com/Cinnamon/kotaemon">https://github.com/Cinnamon/kotaemon</a>
</p>

<p>
Hugging Face 在线体验: <a href="https://huggingface.co/spaces/cin-model/kotaemon-demo">https://huggingface.co/spaces/cin-model/kotaemon-demo</a>
</p>

<p>
官方介绍：
</p>

<p>
This project serves as a functional RAG UI for both end users who want to do QA on their documents and developers who want to build their own RAG pipeline.
</p>

<ul class="org-ul">
<li>For end users:
<ul class="org-ul">
<li>A clean &amp; minimalistic UI for RAG-based QA.</li>
<li>Supports LLM API providers (OpenAI, AzureOpenAI, Cohere, etc) and local LLMs (via <code>ollama</code> and ~llama-cpp-python`).</li>
<li>Easy installation scripts.</li>
</ul></li>
<li>For developers:
<ul class="org-ul">
<li>A framework for building your own RAG-based document QA pipeline.</li>
<li>Customize and see your RAG pipeline in action with the provided UI (built with <a href="https://github.com/gradio-app/gradio">Gradio</a>).</li>
<li>If you use Gradio for development, check out our theme here: <a href="https://github.com/lone17/kotaemon-gradio-theme">kotaemon-gradio-theme</a>.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org54cc18c" class="outline-2">
<h2 id="org54cc18c">Thanks</h2>
<div class="outline-text-2" id="text-org54cc18c">
<p>
这个手册会持续更新，如果对你有所帮助，我会很开心。
</p>

<p>
另见：<a href="https://www.vandee.art/2024-05-22-org-pkm-manual.html">PKM（个人知识管理）构建手册 - Emacs</a>
</p>

<p>
这里是我日常使用的实用小工具： <a href="https://www.vandee.art/2024-07-26-useful-tools-recommended.html">实用小玩意收集</a>
</p>

<p>
Imagining and creating！
</p>
</div>
</div>
<div class="taglist"><a href="https://www.vandee.art/blog/tags.html">Tags</a>: <a href="https://www.vandee.art/blog/tag-pkm.html">PKM</a> </div></div>
<div id="postamble" class="status"><div id="search-results"></div>
      <footer>
         <p>
            © 2022-<script>document.write(new Date().getFullYear())</script> Vandee. All rights reserved.
         </p>
        <div class="social-links"></div>
      </footer>

      <a href="#top" aria-label="go to top" title="Go to Top (Alt + G)"
         class="top-link" id="top-link" accesskey="g">
         <i class="ri-arrow-up-double-line ri-3x"></i>
      </a>

      <script>
        var mybutton = document.getElementById('top-link');
        window.onscroll = function () {
            if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
                mybutton.style.visibility = 'visible';
                mybutton.style.opacity = '1';
            } else {
                mybutton.style.visibility = 'hidden';
                mybutton.style.opacity = '0';
            }
        };
      </script></div>
</body>
</html>
